./appspec.yml:
{
# ./appspec.yml (Corrected)
version: 0.0
os: linux
files:
  - source: / # Copy everything from the build artifact root
    destination: /var/www/photocomp-api # Destination directory on EC2
file_exists_behavior: OVERWRITE
hooks:
  BeforeInstall:
    - location: scripts/stop_server.sh
      timeout: 300
      runas: ec2-user # Use 'ubuntu' if using Ubuntu AMI
    - location: scripts/clean_directory.sh
      timeout: 300
      runas: ec2-user # Use 'ubuntu' if using Ubuntu AMI
  AfterInstall:
    # REMOVED: scripts/set_permissions.sh hook was here - it was incorrect
    - location: scripts/install_dependencies.sh
      timeout: 300
      runas: ec2-user # Use 'ubuntu' if using Ubuntu AMI
    - location: scripts/fetch_env_vars.sh
      timeout: 120
      runas: ec2-user # Use 'ubuntu' if using Ubuntu AMI
  ApplicationStart:
    - location: scripts/start_server.sh
      timeout: 300
      runas: ec2-user # Use 'ubuntu' if using Ubuntu AMI
  ValidateService:
    # KEEP THIS: This validation runs *after* the server starts
    - location: scripts/validate_service.sh
      timeout: 60
      runas: ec2-user # Use 'ubuntu' if using Ubuntu AMI}

./buildspec.yml:
{
version: 0.2

phases:
  install:
    runtime-versions:
      nodejs: 18 # Or 20, depending on your project needs and CodeBuild image support
    commands:
      - echo Installing dependencies...
      - npm ci # Use ci for faster, consistent installs in CI/CD
  build:
    commands:
      - echo Building the project...
      - npm run build # This executes 'tsc' as defined in your package.json
  post_build:
    commands:
      - echo Build completed on `date`
artifacts:
  files:
    - 'dist/**/*'
    - 'package.json'
    - 'package-lock.json'
    - 'appspec.yml'
    - 'scripts/**/*' # Include deployment scripts
    - 'node_modules/**/*' # Include production node_modules
  # If you prefer installing node_modules on the EC2 instance:
  # - Remove 'node_modules/**/*' from files above
  # - Ensure 'npm ci --production' is in the AfterInstall hook script}

./tsconfig.json:
{
{
    "compilerOptions": {
        "target": "ES2020",
        "module": "NodeNext",
        "moduleResolution": "NodeNext",
        "esModuleInterop": true,
        "sourceMap": true,
        "outDir": "dist",
        "strict": true,
        "lib": ["ES2020"],
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true,
        "resolveJsonModule": true,
        "baseUrl": ".",
        "rootDir": "src",
        "paths": {
            "@/*": ["src/*"]
        },
        "isolatedModules": true
    },
    "include": ["src/**/*"],
    "exclude": ["node_modules"]
}
}

./README.md:
{
# PhotoComp API Documentation

This document outlines the API endpoints for the PhotoComp platform, designed for companies to share event photos with their organization members. It includes all required HTTP requests, expected responses, and details about the data models.

## Data Models

### User Model

| Property | Type | Description |
|----------|------|-------------|
| id | string (UUID) | Unique identifier for the user. |
| email | string | User's email address (used for authentication). |
| firstName | string | User's first name. |
| lastName | string | User's last name. |
| password | string | Hashed password (not returned in API responses). |
| role | string | User role: "USER", "MEMBER", or "ADMIN". |
| createdAt | timestamp | Timestamp when the user was created (ISO 8601). |
| updatedAt | timestamp | Timestamp when the user was last updated (ISO 8601). |

### Organization Model

| Property | Type | Description |
|----------|------|-------------|
| id | string (UUID) | Unique identifier for the org. |
| name | string | Organization's unique name. |
| createdBy | string | User's ID (`USER#${user.id}` or user.PK) |
| createdAt | timestamp | Timestamp when the org was created (ISO 8601). |
| updatedAt | timestamp | Timestamp when the org was last updated (ISO 8601). |
| isPublic | boolean | Returns if an org is public or not. |
| logoUrl | string | Photo URL of the org's logo (pre-signed URL for access). |
| logoS3Key | string | S3 key where the logo is stored. |
| description | string | Optional description of the organization. |
| website | string | Optional website URL. |
| contactEmail | string | Optional contact email for the organization. |

### User-Organization Model

| Property | Type | Description |
|----------|------|-------------|
| userId | string | User's ID (`USER#${user.id}` or userOrg.PK)  |
| organizationName | string | Org's name (`ORG#${org.name}` or userOrg.SK) |
| role | string | User role: "USER", "MEMBER", or "ADMIN". |
| joinedAt | timestamp | When user joined the org (ISO 8601). |

### Organization Membership Request Model

| Property       | Type                                  | Description |
|----------------|---------------------------------------|-------------|
| PK           | string                              | Primary partition key: `ORG#<NAME>` |
| SK           | string                              | Primary sort key: `REQUEST#` |
| organizationName | string                         | Name of the organization |
| userId       | string                              | ID of the user making the request |
| requestDate  | string                              | ISO timestamp of when the request was made |
| message      | string *(optional)*                 | Optional message from the user |
| status       | 'PENDING' \| 'APPROVED' \| 'DENIED' | Status of the request |
| type         | 'ORG_REQUEST'                       | Entity type identifier |
| GSI1PK       | string                              | GSI partition key for user lookups: `REQUEST#` |
| GSI1SK       | string                              | GSI sort key for user lookups: `ORG#<NAME>` |

### Event Model
| Property     | Type    | Description |
|-------------|--------|-------------|
| PK          | string | Primary key: `EVENT#<ID>` |
| SK          | string | Static value: `"ENTITY"` |
| title       | string | Event title |
| description | string | Event description |
| visibility  | string | `"PUBLIC"` or `"PRIVATE"` (default: `"PUBLIC"`) |
| date        | string | Event date (ISO 8601 format) |
| createdAt   | string | Timestamp when the event was created (ISO 8601) |
| updatedAt   | string | Timestamp when the event was last updated (ISO 8601) |
| GSI2PK      | string | Organization ID (`ORG#<ID>`) |
| GSI2SK      | string | Event ID (`EVENT#<ID>`) |

### Event User Model (Event Attendant)
| Property     | Type    | Description |
|-------------|--------|-------------|
| PK          | string | User ID: `USER#<ID>` |
| SK          | string | Event ID: `EVENT#<ID>` |
| GSI2PK      | string | Event ID (`EVENT#<ID>`) |
| GSI2SK      | string | User ID (`USER#<ID>`) |

### Photo Model
| Property     | Type    | Description |
|-------------|--------|-------------|
| PK          | string | Primary key: `PHOTO#<ID>` |
| SK          | string | Static value: `"ENTITY"` |
| id          | string | Unique identifier for the photo |
| eventId     | string | ID of the event the photo belongs to |
| url         | string | Pre-signed URL for accessing the original photo |
| urls        | object | Object containing URLs for different photo sizes (thumbnail, medium, large, original) |
| createdAt   | string | Timestamp when the photo was uploaded (ISO 8601) |
| updatedAt   | string | Timestamp when the photo was last updated (ISO 8601) |
| uploadedBy  | string | User ID of the uploader |
| metadata    | object | Photo metadata (title, description, dimensions, size, etc.) |
| GSI2PK      | string | Event ID (`EVENT#<ID>`) |
| GSI2SK      | string | Photo ID (`PHOTO#<ID>`) |

## Database Model

The system uses a single-table design in DynamoDB with the following structure:

| Component | Description |
|-----------|-------------|
| PK | Primary partition key in format [USER: USER#{id}; ORG: ORG#{NAME}; EVENT: EVENT#{id}; PHOTO: PHOTO#{id}] |
| SK | Primary sort key in format [USER/ORG/EVENT/PHOTO: ENTITY; USER-ORG: ORG#{NAME}; USER-EVENT: EVENT#{id}] |
| GSI1PK | Global Secondary Index partition key in format [USER: EMAIL#{email}; ORG: USER#{id}] |
| GSI1SK | Global Secondary Index sort key in format [USER: USER#{id}; ORG: ORG#{NAME}] |
| GSI2PK | Second Global Secondary Index partition key in format [EVENT: ORG#{name}; PHOTO: EVENT#{id}] |
| GSI2SK | Second Global Secondary Index sort key in format [EVENT: EVENT#{id}; PHOTO: PHOTO#{id}] |
| type | Item type identifier used for filtering (e.g., "USER", "ORGANIZATION", "USER_ORG", "EVENT", "PHOTO") |

## API Overview

### Auth 
| Method | Endpoint | Description |
|--------|----------|-------------|
| POST | /api/auth/register | Register a new user |
| POST | /api/auth/login | Login and get authentication token |

---

### Guest 
| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | /guests | Get public organizations |
| GET | /guests/organizations/:id/events | Get public organizations events|

---

### Organization 
| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | /organizations | Get all organizations for the authenticated user |
| POST | /organizations | Create a new organization |

- [ ] TODO: Implement PATCH /organization/:id  - Update org metadata
- [ ] TODO: Implement DELETE /organization/:id  - Delete the entire Org

---

### Organization Requests 
| Method | Endpoint | Description |
|--------|----------|-------------|
| POST | /organizations/:id | Apply to join an organization with events |
| GET | /organizations/:id/requests | Get all pending membership requests |
| PUT | /organizations/:id/requests/:userId | Approve a membership request |
| DELETE | /organizations/:id/requests/:userId | Deny a membership request |

- [ ] TODO: Implement Notifications for acceptance into organization

---

### Organization Members 
| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | /organizations/:id/members | Get organization members |
| PUT | /organizations/:id/members/:userID | Update organization member |
| DELETE | /organizations/:id/members/:userID | Remove organization member |
| DELETE | /organizations/:id/members/:userID/leave | leave an organization |

---

### Organizations Events 
| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | /organizations/:id/events | Get organizations events|
| POST | /organizations/:id/events | Create a new organization event|
| PATCH | /organizations/:id/events/:eventId | Update an event's publicity |
| DELETE | /organizations/:id/events/:eventId/admin | Delete an event and all associated resources |

- [ ] TODO: Implement SendMemberANotification for NEW event at organization


---

### Organizations Events Attendance
| Method | Endpoint | Description |
|--------|----------|-------------|
| POST | /organizations/:id/events/:eventId | Attend an event |
| DELETE | /organizations/:id/events/:eventId | Leave an event |

- [ ] TODO: Implement Admin remove member from event
- [ ] TODO: Implement Admin remove member from event

---

### Organizations Events Photos
| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | /organizations/:id/events/:eventId/photos | Get all photos for an event |
| POST | /organizations/:id/events/:eventId/photos | Upload a photo to an event |
| DELETE | /organizations/:id/events/:eventId/photos/:photoId | Delete a photo |
| GET | /organizations/:id/events/:eventId/photos/:photoId/download?size=original | Get a download URL for a specific photo size |
| GET | /organizations/:id/photos?size=medium | Get all photos across all organization events with preferred size |

--- 

### Users
| Method | Endpoint | Description |
|--------|----------|-------------|
| DELETE | /api/auth/users/:userId | Delete the user account |
| GET | /users/:userId/events | Get all the user's events  |
| GET | /users/:userId/tagged-photos | Get all photos a user is tagged in|

- [ ] TODO: GET `/users/:userId` - Get all the user's information
- [ ] TODO: PUT `/users/:userId` - Update the user's information 
- [ ] TODO: GET `/users/:userId/organizations` - Get all the user's organizations 

--- 

### Organizations Events Photos Tags
| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | /organizations/:id/events/:eventId/photos/:photoId/tags | Get all tagged users for photo|
| POST | /organizations/:id/events/:eventId/photos/:photoId/tags | Add multiple users to a photo|
| DELETE | /organizations/:id/events/:eventId/photos/:photoId/tags/:userId | Remove a tagged user from photo|

--- 

- [ ] TODO: Implement following endpoints 

### Organizations Events Member Attendance
| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | /organizations/:id/events/:eventId/attendants | Get all events attendants |
| DELETE | /organizations/:id/events/:eventId/attendants/:userId | Remove an event attendant|


### Organizations Events Photos Tags
| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | /organizations/:id/events/:eventId/photos/:photoId/tags | Get all tagged users for photo|
| POST | /organizations/:id/events/:eventId/photos/:photoId/tags | Add multiple users to a photo|
| DELETE | /organizations/:id/events/:eventId/photos/:photoId/tags/:userId | Remove a tagged user from photo|
| GET | /users/:userId/tagged-photos | Get all photos a user is tagged in|

### Users
| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | /users/:userId | Get all the user's information|
| PUT | /users/:userId | Update the user's information |
| DELETE | /users/:userId | Delete the user account |
| GET | /users/:userId/organizations | Get all the user's organizations |
| GET | /users/:userId/events | Get all the user's events  |
| GET | /users/:userId/photos | Get all the user's photos  |


> For more details please check `docs/`}

./package.json:
{
{
    "name": "photocomp--node-express",
    "version": "1.0.0",
    "description": "",
    "main": "index.js",
    "scripts": {
        "build": "tsc",
        "start": "ts-node src/index.ts",
        "dev": "nodemon --exec ts-node src/index.ts",
        "test": "jest",
        "coverage": "jest --coverage",
        "format": "prettier . --write"
    },
    "keywords": [],
    "author": "",
    "license": "ISC",
    "devDependencies": {
        "@babel/preset-env": "^7.26.9",
        "@babel/preset-typescript": "^7.27.0",
        "@types/cors": "^2.8.17",
        "@types/express": "^4.17.17",
        "@types/jest": "^29.5.14",
        "@types/jsonwebtoken": "^9.0.9",
        "@types/multer": "^1.4.12",
        "@types/node": "^22.13.13",
        "@types/nodemailer": "^6.4.17",
        "@types/sharp": "^0.32.0",
        "@types/supertest": "^6.0.3",
        "@types/swagger-ui-express": "^4.1.8",
        "jest": "^29.7.0",
        "nodemon": "^3.1.9",
        "prettier": "^3.5.3",
        "supertest": "^7.1.0",
        "ts-jest": "^29.3.0",
        "ts-node": "^10.9.2"
    },
    "dependencies": {
        "@aws-sdk/client-dynamodb": "^3.772.0",
        "@aws-sdk/client-s3": "^3.779.0",
        "@aws-sdk/lib-dynamodb": "^3.772.0",
        "@aws-sdk/s3-request-presigner": "^3.779.0",
        "bcryptjs": "^3.0.2",
        "cors": "^2.8.5",
        "dotenv": "^16.4.7",
        "express": "^4.21.2",
        "jsonwebtoken": "^9.0.2",
        "multer": "^1.4.5-lts.2",
        "nodemailer": "^6.10.0",
        "photocomp--node-express": "file:",
        "sharp": "^0.33.2",
        "swagger-ui-express": "^5.0.1",
        "typescript": "^5.8.2",
        "uuid": "^11.1.0",
        "winston": "3.14.2"
    }
}}

./dynamodb-cloudformation.yaml:
{
AWSTemplateFormatVersion: '2010-09-09'
Description: 'CloudFormation template for PhotoComp DynamoDB table'

Parameters:
    ApplicationName:
        Type: String
        Default: PhotoComp
        Description: Name of the application

    Environment:
        Type: String
        Default: Dev
        AllowedValues:
            - Dev
            - Test
            - Prod
        Description: Deployment environment

Resources:
    PhotoCompTable:
        Type: AWS::DynamoDB::Table
        Properties:
            # Use dynamic table name with environment to make it unique
            TableName: !Sub '${ApplicationName}-${Environment}-Table'
            BillingMode: PAY_PER_REQUEST
            AttributeDefinitions:
                - AttributeName: PK
                  AttributeType: S
                - AttributeName: SK
                  AttributeType: S
                - AttributeName: GSI1PK
                  AttributeType: S
                - AttributeName: GSI1SK
                  AttributeType: S
                - AttributeName: GSI2PK
                  AttributeType: S
                - AttributeName: GSI2SK
                  AttributeType: S
            KeySchema:
                - AttributeName: PK
                  KeyType: HASH
                - AttributeName: SK
                  KeyType: RANGE
            GlobalSecondaryIndexes:
                - IndexName: GSI1PK-GSI1SK-INDEX
                  KeySchema:
                      - AttributeName: GSI1PK
                        KeyType: HASH
                      - AttributeName: GSI1SK
                        KeyType: RANGE
                  Projection:
                      ProjectionType: ALL
                - IndexName: GSI2PK-GSI2SK-INDEX # Added new GSI for photo queries by event
                  KeySchema:
                      - AttributeName: GSI2PK
                        KeyType: HASH
                      - AttributeName: GSI2SK
                        KeyType: RANGE
                  Projection:
                      ProjectionType: ALL
            PointInTimeRecoverySpecification:
                PointInTimeRecoveryEnabled: false
            SSESpecification:
                SSEEnabled: true
            Tags:
                - Key: Application
                  Value: !Ref ApplicationName
                - Key: Environment
                  Value: !Ref Environment
}

./jest.config.js:
{
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
    preset: 'ts-jest',
    testEnvironment: 'node',
    testMatch: ['**/__tests__/**/*.test.ts'],
    transform: {
        '^.+\\.tsx?$': 'ts-jest',
    },
    moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],
    clearMocks: true,
    collectCoverage: true,
    coverageDirectory: 'coverage',
    // Ensure TypeScript paths mappings are handled correctly
    moduleNameMapper: {
        '^@/(.*)$': '<rootDir>/src/$1',
    },
    // Add roots to help with module resolution
    roots: ['<rootDir>'],
    modulePaths: ['<rootDir>'],
};
}

src/config/db.ts:
{
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocumentClient } from '@aws-sdk/lib-dynamodb';
import dotenv from 'dotenv';

dotenv.config();

const client = new DynamoDBClient({ region: process.env.REGION as string });
const dynamoDb = DynamoDBDocumentClient.from(client);

export const TABLE_NAME = process.env.TABLE_NAME;

export { dynamoDb };
}

src/config/multer.ts:
{
import multer from 'multer';

// Configure storage to memory
const storage = multer.memoryStorage();

// Configure multer with limits
export const multerConfig = {
    storage: storage,
    limits: {
        fileSize: 5 * 1024 * 1024, // 5MB max file size
    },
};
}

src/config/s3.ts:
{
import { S3Client } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import dotenv from 'dotenv';

dotenv.config();

const s3Client = new S3Client({ region: process.env.REGION as string });

export const S3_BUCKET_NAME = process.env.S3_BUCKET_NAME as string;

export { s3Client, getSignedUrl };
}

src/controllers/authController.ts:
{
import { Request, Response, NextFunction, Router } from 'express';
import { UserService } from '../services/userService';
import { AuthRequest, RegisterRequest, UserRole, PasswordChangeRequest } from '../models/User';
import { AppError } from '../middleware/errorHandler';
import { authenticate } from '../middleware/authMiddleware';

const userService = new UserService();
export const authRouter = Router();

/**
 * Register a new user
 * @route POST /api/auth/register
 */
authRouter.post('/register', async (req: Request, res: Response, next: NextFunction) => {
    try {
        // Validate request body
        const { email, password, firstName, lastName } = req.body;

        if (!email || !password || !firstName || !lastName) {
            throw new AppError('Email, password, first name, and last name are required', 400);
        }

        // Validate email format
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(email)) {
            throw new AppError('Invalid email format', 400);
        }

        // Validate password strength
        if (password.length < 8) {
            throw new AppError('Password must be at least 8 characters long', 400);
        }

        const registerRequest: RegisterRequest = {
            email,
            password,
            firstName,
            lastName,
        };

        // Register the user
        const result = await userService.register(registerRequest);

        // Return the user data and token
        return res.status(201).json({
            status: 'success',
            data: {
                user: result.user,
                token: result.token,
            },
        });
    } catch (error) {
        // Pass all errors to the error middleware
        next(error);
    }
});

/**
 * Delete a user account
 * @route DELETE /api/auth/users/:id
 */
authRouter.delete(
    '/users/:id',
    authenticate,
    async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userId = req.params.id;
            const requestingUserId = res.locals.user.id;

            // Only allow users to delete their own account
            if (userId !== requestingUserId) {
                throw new AppError('Not authorized to delete this user', 403);
            }

            const result = await userService.deleteUser(userId);

            return res.status(200).json({
                status: 'success',
                message: 'User deleted successfully',
            });
        } catch (error) {
            next(error);
        }
    }
);

/**
 * Login an existing user
 * @route POST /api/auth/login
 */
authRouter.post('/login', async (req: Request, res: Response, next: NextFunction) => {
    try {
        // Validate request body
        const { email, password } = req.body;

        if (!email || !password) {
            throw new AppError('Email and password are required', 400);
        }

        const authRequest: AuthRequest = {
            email,
            password,
        };

        // Login the user
        const result = await userService.login(authRequest);

        // Return the user data and token
        return res.status(200).json({
            status: 'success',
            data: {
                user: result.user,
                token: result.token,
            },
        });
    } catch (error) {
        // Pass all errors to the error middleware
        next(error);
    }
});

/**
 * Change user password
 * @route PATCH /api/auth/password
 */
authRouter.patch(
    '/password',
    authenticate,
    async (req: Request, res: Response, next: NextFunction) => {
        try {
            // Validate request body
            const { currentPassword, newPassword } = req.body;
            const userId = res.locals.user.id;

            if (!currentPassword || !newPassword) {
                throw new AppError('Current password and new password are required', 400);
            }

            // Validate new password strength
            if (newPassword.length < 8) {
                throw new AppError('New password must be at least 8 characters long', 400);
            }

            // Ensure new password is different from current
            if (currentPassword === newPassword) {
                throw new AppError('New password must be different from current password', 400);
            }

            const passwordChangeRequest: PasswordChangeRequest = {
                userId,
                currentPassword,
                newPassword,
            };

            // Update the password
            await userService.changePassword(passwordChangeRequest);

            return res.status(200).json({
                status: 'success',
                message: 'Password changed successfully',
            });
        } catch (error) {
            next(error);
        }
    }
);}

src/controllers/eventController.ts:
{
import { Request, Response, NextFunction, Router } from 'express';
import { EventService } from '../services/eventService';
import { OrgService } from '../services/orgService';
import { EventRequest, Event, EventUser } from '../models/Event';
import { Status } from '../models/Response';
import { checkOrgAdmin, checkOrgMember } from '../middleware/OrgMiddleware'; // Added checkOrgMember
import { UserOrganizationRelationship } from '../models/Organizations';
import { AppError } from '../middleware/errorHandler';
import { WeatherService } from '../services/weatherService';
import { GeocodingService } from '../services/geocodingService';
import { TagService, AttendeeWithDetails } from '../services/tagService'; // Import AttendeeWithDetails

const eventService = new EventService();
const orgService = new OrgService();
const weatherService = new WeatherService();
const geocodingService = new GeocodingService();
const tagService = new TagService();

export const eventRouter = Router({ mergeParams: true });

/*
 * Create an organization's event
 * POST /events
 * Added support for address field to automatically geocode and fetch weather
 */
eventRouter.post('/', checkOrgAdmin, async (req: Request, res: Response, next: NextFunction) => {
    try {
        const orgName: string = req.params.orgId;
        const orgAdmin = res.locals.user as { id: string; email: string; role: string };

        console.log(`Organization name from params: "${orgName}"`);

        const eventRequest: EventRequest = {
            title: req.body.title,
            description: req.body.description,
            date: req.body.date,
            location: req.body.location,
            address: req.body.address, // Include optional address field for geocoding
        };

        const event: Event = await eventService.addEventToOrganization(orgName, eventRequest);
        const userEvent: EventUser = await eventService.addEventUser(orgAdmin.id, event.id);

        // Email notification functionality from HEAD version
        const members: UserOrganizationRelationship[] = await orgService.getOrgMembers(orgName);

        // Prepare response data with separate structures for event and geocoding info
        const responseData: Array<Event | EventUser | Record<string, any>> = [userEvent, event];

        // If address was provided and successfully geocoded, add info to response
        if (eventRequest.address && event.location) {
            responseData.push({
                geocoding: {
                    providedAddress: eventRequest.address,
                    resolvedCoordinates: {
                        latitude: event.location.latitude,
                        longitude: event.location.longitude,
                        formattedAddress: event.location.name,
                    },
                },
            });
        }

        // Prepare success response with combined data
        const status: Status = {
            statusCode: 201,
            status: 'success',
            data: responseData,
        };

        // Add email notification if members exist
        if (members && members.length > 0) {
            const membersEmail: string[] = members.map(member => member.email);

            // Creates the email data.
            const to: string = membersEmail.toString();
            const subject: string = `An update from PhotoComp!`;
            const message: string = `Don't miss updates on this event: ${req.body.title} - ${req.body.date}.
                    Know more by checking out the website!`;
            const header: string = `A new event in ${orgName} has been created!`;

            res.locals.user.emailInfo = { to, message, header, subject };
        }

        next(status);
    } catch (error) {
        next(error);
    }
});

/*
 * Get the organizations events
 * GET /events
 * Protected by checkOrgMember middleware
 */
eventRouter.get('/', checkOrgMember, async (req: Request, res: Response, next: NextFunction) => {
    const orgID: string = req.params.orgId;
    try {
        const events: Event[] = await eventService.getAllOrganizationEvents(orgID);
        return res.status(200).json({
            status: 'success',
            data: {
                events: events,
            },
        });
    } catch (error) {
        next(error);
    }
});

/*
 * Get details of a specific event *AND* its attendees with details
 * GET /events/:eid
 * Protected by checkOrgMember middleware
 */
eventRouter.get(
    '/:eid',
    checkOrgMember, // Ensure only org members can access event details
    async (req: Request, res: Response, next: NextFunction) => {
        try {
            const eventId: string = req.params.eid;
            const orgId: string = req.params.orgId; // Get orgId from route params

            // Fetch event details
            const eventDetails = await eventService.findEventById(eventId);
            if (!eventDetails) {
                throw new AppError('Event not found', 404);
            }

            // Fetch attendees with their details using the updated TagService method
            const attendees: AttendeeWithDetails[] = await tagService.getEventAttendeesWithDetails(eventId);

            // Return both event details and attendee details
            return res.status(200).json({
                status: 'success',
                data: {
                    event: eventDetails,
                    attendees: attendees, // Return the enriched attendee list
                },
            });
        } catch (error) {
            next(error);
        }
    }
);

/*
 * Update event's publicity
 * PATCH /events/:eid
 */
eventRouter.patch(
    '/:eid',
    checkOrgAdmin,
    async (req: Request, res: Response, next: NextFunction) => {
        const eventId: string = req.params.eid;
        const user = res.locals.user.info;

        try {
            const event = await eventService.findEventById(eventId);
            if (!event) {
                throw new AppError('Event not found', 404);
            }

            await eventService.findEventUserbyUser(eventId, user.id);

            const updatedEvent = await eventService.updateEventPublicity(event as Event);

            return res.status(200).json({
                status: "Updating Event's publicity success!",
                data: {
                    updatedEvent,
                },
            });
        } catch (error) {
            next(error);
        }
    }
);

/*
 * Create an Attendance record for an event
 * POST /events/:eid
 * Protected by checkOrgMember middleware
 */
eventRouter.post('/:eid', checkOrgMember, async (req: Request, res: Response, next: NextFunction) => {
    try {
        const eventId: string = req.params.eid;
        const member = res.locals.user as { id: string; email: string; role: string };

        const userEvent: EventUser = await eventService.addEventUser(member.id, eventId);

        return res.status(201).json({
            status: 'success',
            data: {
                userEvent,
            },
        });
    } catch (error) {
        next(error);
    }
});

/*
 * Remove the Attendance record for an event
 * DELETE /events/:eid
 * Protected by checkOrgMember middleware
 */
eventRouter.delete('/:eid', checkOrgMember, async (req: Request, res: Response, next: NextFunction) => {
    try {
        const eventId: string = req.params.eid;
        const member = res.locals.user as { id: string; email: string; role: string };

        await eventService.removeEventUser(member.id, eventId);

        return res.status(200).json({ // Changed status to 200 for successful DELETE
            status: 'success',
            message: 'Attendance removed successfully',
        });
    } catch (error) {
        next(error);
    }
});

/*
 * Refresh weather data for an event
 * POST /events/:eid/weather/refresh
 */
eventRouter.post(
    '/:eid/weather/refresh',
    checkOrgAdmin,
    async (req: Request, res: Response, next: NextFunction) => {
        try {
            const eventId: string = req.params.eid;

            const updatedEvent = await eventService.refreshEventWeather(eventId);

            return res.status(200).json({
                status: 'success',
                data: {
                    event: updatedEvent,
                },
            });
        } catch (error) {
            next(error);
        }
    }
);

/*
 * Update event location and fetch weather data
 * PATCH /events/:eid/location
 */
eventRouter.patch(
    '/:eid/location',
    checkOrgAdmin,
    async (req: Request, res: Response, next: NextFunction) => {
        try {
            const eventId: string = req.params.eid;
            const { latitude, longitude, name } = req.body;

            if (typeof latitude !== 'number' || typeof longitude !== 'number') {
                throw new AppError('Valid latitude and longitude are required', 400);
            }

            // First get the existing event
            const event = await eventService.findEventById(eventId);

            if (!event) {
                throw new AppError('Event not found', 404);
            }

            // Update event with location data
            event.location = {
                latitude,
                longitude,
                name: name || undefined,
            };

            // Update event in database
            const updatedEvent = await eventService.updateEvent(event);

            // Fetch and add weather data
            try {
                const weatherData = await weatherService.getWeatherForLocation(
                    latitude,
                    longitude,
                    event.date
                );

                const eventWithWeather = await eventService.updateEventWeather(
                    eventId,
                    weatherData
                );

                return res.status(200).json({
                    status: 'success',
                    data: {
                        event: eventWithWeather,
                    },
                });
            } catch (weatherError) {
                // Return updated event even if weather fetch fails
                return res.status(200).json({
                    status: 'success',
                    message: 'Location updated but weather data could not be fetched',
                    data: {
                        event: updatedEvent,
                    },
                });
            }
        } catch (error) {
            next(error);
        }
    }
);

/*
 * Update event location using an address and fetch weather data
 * PATCH /events/:eid/location/address
 */
eventRouter.patch(
    '/:eid/location/address',
    checkOrgAdmin,
    async (req: Request, res: Response, next: NextFunction) => {
        try {
            const eventId: string = req.params.eid;
            const { address } = req.body;

            if (!address || typeof address !== 'string') {
                throw new AppError('Valid address is required', 400);
            }

            // First get the existing event
            const event = await eventService.findEventById(eventId);

            if (!event) {
                throw new AppError('Event not found', 404);
            }

            // Geocode the address to get coordinates
            const geocodingResult = await geocodingService.geocodeAddress(address);

            // Update event with location data
            event.location = {
                latitude: geocodingResult.latitude,
                longitude: geocodingResult.longitude,
                name: geocodingResult.displayName,
            };

            // Update event in database
            const updatedEvent = await eventService.updateEvent(event);

            // Fetch and add weather data
            try {
                const weatherData = await weatherService.getWeatherForLocation(
                    geocodingResult.latitude,
                    geocodingResult.longitude,
                    event.date
                );

                const eventWithWeather = await eventService.updateEventWeather(
                    eventId,
                    weatherData
                );

                return res.status(200).json({
                    status: 'success',
                    data: {
                        event: eventWithWeather,
                        geocoding: {
                            latitude: geocodingResult.latitude,
                            longitude: geocodingResult.longitude,
                            formattedAddress: geocodingResult.displayName,
                        },
                    },
                });
            } catch (weatherError) {
                // Return updated event even if weather fetch fails
                return res.status(200).json({
                    status: 'success',
                    message: 'Location updated but weather data could not be fetched',
                    data: {
                        event: updatedEvent,
                        geocoding: {
                            latitude: geocodingResult.latitude,
                            longitude: geocodingResult.longitude,
                            formattedAddress: geocodingResult.displayName,
                        },
                    },
                });
            }
        } catch (error) {
            next(error);
        }
    }
);

/*
 * Get all a User's Events
 * GET /users/:userId/events
 */
export const getUserEvents = async (req: Request, res: Response, next: NextFunction) => {
    try {
        const userId = req.params.userId;
        const requestingUserId = res.locals.user.id;

        if (userId !== requestingUserId) {
            throw new AppError("You cannot get this user's events", 403);
        }

        const events = await eventService.getAllUserEvents(userId);
        const eventsWithDetails = await Promise.all(
            events.map(async request => {
                const eventDetails = await eventService.findEventById(request.id);
                return {
                    ...request,
                    event: eventDetails
                        ? {
                            title: eventDetails.title,
                            description: eventDetails.description,
                            date: eventDetails.date,
                            weather: eventDetails.weather,
                            location: eventDetails.location,
                        }
                        : null,
                };
            })
        );

        return res.status(200).json({
            status: 'success',
            events: eventsWithDetails,
        });
    } catch (error) {
        next(error);
    }
};

/*
 * Delete an event and all associated resources
 * DELETE /events/:eid/admin
 */
eventRouter.delete(
    '/:eid/admin',
    checkOrgAdmin,
    async (req: Request, res: Response, next: NextFunction) => {
        try {
            const orgName: string = req.params.orgId;
            const eventId: string = req.params.eid;
            const admin = res.locals.user as { id: string; email: string; role: string };

            // Delete the event and all associated resources (attendance, photos)
            await eventService.deleteEvent(orgName, eventId, admin.id);

            return res.status(200).json({
                status: 'success',
                message: 'Event deleted successfully'
            });
        } catch (error) {
            next(error);
        }
    }
);
}

src/controllers/guestController.ts:
{
import { Request, Response, Router, NextFunction } from 'express';
import { OrgService } from '../services/orgService';
import { AppError } from '../middleware/errorHandler';
import { EventService } from '../services/eventService';
import { S3Service } from '../services/s3Service';
import { logger } from '../util/logger';

const orgService = new OrgService();
const eventService = new EventService();
const s3Service = new S3Service();

export const guestRouter = Router();

/*
 * Should be able to view all the public organizations, and their public
 * events.
 *
 * Limits the total organizations to 9 per request (via orgRepo);
 * */
guestRouter.get(`/`, async (req: Request, res: Response, next: NextFunction) => {
    try {
        let lastEvaluatedKey = undefined;

        if (req.query.lastEvaluatedKey && req.query.lastEvaluatedKey !== 'undefined') {
            try {
                const decodedKey = decodeURIComponent(req.query.lastEvaluatedKey as string);
                if (decodedKey) {
                    lastEvaluatedKey = JSON.parse(decodedKey);
                }
            } catch (parseError) {
                console.error("Error parsing lastEvaluatedKey:", parseError);
            }
        }

        const { orgs, newLastEvaluatedKey } = await orgService.findAllPublicOrgs(
            lastEvaluatedKey as Record<string, any>
        );

        if (!orgs || orgs.length === 0) {
            throw new AppError(`No organizations found!`, 204);
        }

        // Refresh all logo pre-signed URLs for the frontend
        for (const org of orgs) {
            if (org.logoS3Key) {
                try {
                    // Generate a new pre-signed URL for the logo
                    org.logoUrl = await s3Service.getLogoPreSignedUrl(org.logoS3Key);
                    logger.debug(`Refreshed logo URL for organization ${org.name} in guest route`);
                } catch (error) {
                    // Log the error but continue processing other organizations
                    logger.error(`Error refreshing logo URL for org ${org.name || org.id}:`, error);
                    // If we can't generate a new URL, at least keep the existing one
                }
            }
        }

        return res.status(200).json({
            message: `Here are all organizations!`,
            data: {
                organizations: orgs,
            },
            lastEvaluatedKey: newLastEvaluatedKey,
        });
    } catch (error) {
        next(error);
    }
});

/*
 * Returning the public events from a specific organizations
 *
 * Limits the total events to 9 per request (via eventRepo);
 * */
guestRouter.get(
    '/organizations/:id/events',
    async (req: Request, res: Response, next: NextFunction) => {
        const orgID: string = req.params.id;

        try {
            const { events, newLastEvaluatedKey } =
                await eventService.getAllPublicOrganizationEvents(orgID);

            if (!events || events.length === 0) {
                throw new AppError(`No public events found!`, 204);
            }

            return res.status(200).json({
                status: 'success',
                data: {
                    events: events,
                },
                lastEvaluatedKey: newLastEvaluatedKey,
            });
        } catch (error) {
            next(error);
        }
    }
);}

src/controllers/orgController.ts:
{
import { Request, Response, Router, NextFunction } from 'express';
import { UserService } from '../services/userService';
import { OrgService } from '../services/orgService';
import {
    Organization,
    OrganizationCreateRequest,
    OrganizationUpdateRequest,
    UserOrganizationRelationship,
} from '../models/Organizations';
import { AppError } from '../middleware/errorHandler';
import { checkOrgAdmin, validateUserID } from '../middleware/OrgMiddleware';
import { handleLogoUpload } from '../middleware/orgLogoUploadMiddleware';

const orgService = new OrgService();
export const orgRouter = Router();

/*
 * Get all orgs that a User is a part of
 * GET /organizations
 * */
orgRouter.get(`/`, async (req: Request, res: Response, next: NextFunction) => {
    try {
        const user = res.locals.user.info;

        const org = await orgService.findOrgsByUser(user.id);

        if (!org) {
            throw new AppError(`No organizations found!`, 204);
        }

        res.status(200).json({ message: `Here are your organizations!`, org: org });
    } catch (error) {
        next(error);
    }
});

/*
 * Create a new organization, and make the creator an Admin
 * POST /organizations
 * */
orgRouter.post(`/`,
    handleLogoUpload('logo'), // Add middleware for logo file upload
    async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { name, description, website, contactEmail } = req.body;
            const user = res.locals.user.info;

            // Check if logo file was uploaded
            if (!req.file) {
                throw new AppError('Logo file is required', 400);
            }

            // Prepare organization request without logoUrl (will be generated from file)
            const organizationRequest: Omit<OrganizationCreateRequest, 'logoUrl'> = {
                name,
                description,
                website,
                contactEmail
            };

            // Use the new method that handles file uploads
            const org = await orgService.createOrgWithFileUpload(
                organizationRequest,
                user.id,
                req.file.buffer,
                req.file.mimetype
            );

            if (org) {
                try {
                    const userAdmin = await orgService.createUserAdmin(name, user.id, user.email);

                    if (userAdmin) {
                        res.status(201).json({
                            status: 'Created organization!',
                            data: {
                                user: userAdmin.userId,
                                org: org.name,
                                logoUrl: org.logoUrl, // Return the pre-signed URL
                                logoS3Key: org.logoS3Key, // Return the S3 key for reference
                            },
                        });
                    }
                } catch (error: any) {
                    throw new AppError(`User Organization not created`, 400);
                }
            } else {
                throw new AppError(`Organization not created`, 400);
            }
        } catch (error) {
            next(error);
        }
    });

/*
 * Update an organization's information
 * PATCH /organizations
 * remove admin
 * */
orgRouter.patch(`/:id`,
    handleLogoUpload('logo'),  // Add middleware for logo file upload (optional)
    async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { description, website, contactEmail } = req.body;
            const user = res.locals.user.info;
            const orgName: string = req.params.orgId || req.params.id;

            // Validate URLs if provided
            await orgService.validateUrl(website);

            const existingOrg = await orgService.findOrgByName(orgName);

            if (!existingOrg) {
                throw new AppError(`No Organizations found!`, 400);
            }
            console.log(`found org`);
            let logoUrl = existingOrg.logoUrl;
            let logoS3Key = existingOrg.logoS3Key;

            // Handle logo file upload if provided
            if (req.file) {
                const logoData = await orgService.updateOrgLogoWithFile(
                    orgName,
                    req.file.buffer,
                    req.file.mimetype
                );
                logoUrl = logoData.logoUrl;
                logoS3Key = logoData.logoS3Key;
            }
            console.log(`after logo file`);
            const org: OrganizationUpdateRequest = {
                name: orgName,
                logoUrl,
                description,
                website,
                contactEmail,
            };

            const updatedOrg = await orgService.updateOrgByName(org);
            console.log(`after update`);
            if (!updatedOrg) {
                throw new AppError(`Failed to update Organization`, 400);
            }
            console.log(`before res`)
            res.status(200).json({
                status: 'Updated organization!',
                data: {
                    org: updatedOrg,
                },
            });
        } catch (error) {
            next(error);
        }
    });
}

src/controllers/orgMemberController.ts:
{
import { Request, Response, Router, NextFunction } from 'express';
import { OrgService } from '../services/orgService';
import { checkOrgAdmin } from '../middleware/OrgMiddleware';
import { AppError } from '../middleware/errorHandler';
import { UserRole } from '../models/User';
import { UserService } from '../services/userService';

const orgService = new OrgService();
const userService = new UserService();
export const orgMemberRouter = Router({ mergeParams: true });

/**
 * Get all members of an organization
 * @route GET /members
 */
orgMemberRouter.get('/', checkOrgAdmin, async (req: Request, res: Response, next: NextFunction) => {
    try {
        const orgName: string = req.params.orgId;

        const members = await orgService.getOrgMembers(orgName);
        const membersWithUserDetails = await Promise.all(
            members.map(async request => {
                const user = await userService.getUserById(request.userId);
                return {
                    ...request,
                    userDetails: user
                        ? {
                              id: user.id,
                              email: user.email,
                              firstName: user.firstName,
                              lastName: user.lastName,
                          }
                        : null,
                };
            })
        );

        return res.status(200).json({
            status: 'success',
            data: {
                members: membersWithUserDetails,
            },
        });
    } catch (error) {
        next(error);
    }
});

/**
 * Remove a member from an organization
 * @route DELETE /members/:userId
 */
orgMemberRouter.delete(
    '/:userId',
    checkOrgAdmin,
    async (req: Request, res: Response, next: NextFunction) => {
        try {
            const orgName: string = req.params.orgId;
            const userId: string = req.params.userId;
            const adminId = res.locals.user.id;

            // Prevent admins from removing themselves
            if (userId === adminId) {
                throw new AppError(
                    'Administrators cannot remove themselves from the organization',
                    400
                );
            }

            await orgService.removeMember(orgName, userId);

            return res.status(200).json({
                status: 'success',
                message: 'Member removed successfully',
            });
        } catch (error) {
            next(error);
        }
    }
);

/**
 * Update a member's role in an organization
 * @route PATCH /members/:userId
 */
orgMemberRouter.patch(
    '/:userId',
    checkOrgAdmin,
    async (req: Request, res: Response, next: NextFunction) => {
        try {
            const orgName: string = req.params.orgId;
            const userId: string = req.params.userId;
            const { role } = req.body;
            const adminId = res.locals.user.id;

            // Validate role
            if (!role || (role !== UserRole.ADMIN && role !== UserRole.MEMBER)) {
                throw new AppError('Role must be either ADMIN or MEMBER', 400);
            }

            // Prevent admins from changing their own role
            if (userId === adminId) {
                throw new AppError('Administrators cannot change their own role', 400);
            }

            const updatedMember = await orgService.updateMemberRole(
                orgName,
                userId,
                role as UserRole
            );

            return res.status(200).json({
                status: 'success',
                message: 'Member role updated successfully',
                data: {
                    member: updatedMember,
                },
            });
        } catch (error) {
            next(error);
        }
    }
);

/**
 * Remove a member from an organization
 * @route DELETE /members/:userId/leave
 */
orgMemberRouter.delete(
    '/:userId/leave',
    async (req: Request, res: Response, next: NextFunction) => {
        try {
            const orgName: string = req.params.orgId;
            const user = res.locals.user;

            await orgService.leaveOrganization(orgName, user.id);

            return res.status(200).json({
                status: 'success',
                message: 'Successfully left the organization',
            });
        } catch (error) {
            next(error);
        }
    }
);
}

src/controllers/orgMemberShipController.ts:
{
import { Request, Response, Router, NextFunction } from 'express';
import { OrgMembershipService } from '../services/orgMembershipService';
import { checkOrgAdmin, validateUserID } from '../middleware/OrgMiddleware';
import {
    OrganizationMembershipRequest,
    UserOrganizationRelationship,
} from '../models/Organizations';
import { Status } from '../models/Response';
import { UserService } from '../services/userService';

const orgMembershipService = new OrgMembershipService();
const userService = new UserService();
export const orgMembershipRouter = Router();

/**
 * Apply to join an organization
 * @route POST /organizations/:id
 */
orgMembershipRouter.post('/:id', async (req: Request, res: Response, next: NextFunction) => {
    try {
        const orgName: string = req.params.id;
        const user = res.locals.user;
        const { message } = req.body;

        const request = await orgMembershipService.applyToOrganization(orgName, user.id, message);

        return res.status(201).json({
            status: 'success',
            message: 'Application submitted successfully',
            data: {
                request,
            },
        });
    } catch (error) {
        next(error);
    }
});

/**
 * Get pending membership requests for an organization
 * @route GET /organizations/:id/requests
 */
orgMembershipRouter.get(
    '/:id/requests',
    async (req: Request, res: Response, next: NextFunction) => {
        try {
            const orgName: string = req.params.id;
            const requests: OrganizationMembershipRequest[] =
                await orgMembershipService.getPendingRequests(orgName);
            // If there are requests, get user details for each
            const requestsWithUserDetails = await Promise.all(
                requests.map(async request => {
                    const user = await userService.getUserById(request.userId);
                    return {
                        ...request,
                        userDetails: user
                            ? {
                                  id: user.id,
                                  email: user.email,
                                  firstName: user.firstName,
                                  lastName: user.lastName,
                              }
                            : null,
                    };
                })
            );

            return res.status(200).json({
                status: 'success',
                data: {
                    requests: requestsWithUserDetails,
                },
            });
        } catch (error) {
            next(error);
        }
    }
);

/**
 * Approve a membership request
 * @route PUT /organizations/:id/requests/:userId
 */
orgMembershipRouter.put(
    '/:id/requests/:userId',
    async (req: Request, res: Response, next: NextFunction) => {
        try {
            console.log(`put method`);
            const orgName: string = req.params.id;
            const userId: string = req.params.userId; // member userid
            //console.log(`member ${userId}`)
            const result = await orgMembershipService.approveRequest(orgName, userId);
            console.log(`member ${result}`);
            //gets member's email
            const member = await userService.getUserById(userId);
            console.log(`member ${userId}`);
            // Prepare success response with combined data
            const status: Status = {
                statusCode: 200,
                status: 'success',
                data: [
                    `Membership request approved` as any,
                    result as UserOrganizationRelationship,
                ],
            };
            console.log(member);
            // Add email notification if members exist
            if (member) {
                // Creates the email data.
                const to: string = member.email;
                const subject: string = `An update from PhotoComp!`;
                const message: string = `You will now get updates about about ${orgName}.
                    Know more by checking out the website!`;
                const header: string = `Your membership application for ${orgName} has been approved!`;

                res.locals.user.emailInfo = { to, message, header, subject };
            }

            next(status);
        } catch (error) {
            next(error);
        }
    }
);

/**
 * Deny a membership request
 * @route POST /organizations/:id/requests/:userId
 */
orgMembershipRouter.delete(
    '/:id/requests/:userId',
    async (req: Request, res: Response, next: NextFunction) => {
        try {
            const orgName: string = req.params.id;
            const userId: string = req.params.userId;

            const result = await orgMembershipService.denyRequest(orgName, userId);
            //gets member's email
            const member = await userService.getUserById(userId);

            // Prepare success response with combined data
            const status: Status = {
                statusCode: 200,
                status: 'success',
                data: [`Membership request denied` as any, result],
            };

            // Add email notification if members exist
            if (member) {
                // Creates the email data.
                const to: string = member.email;
                const subject: string = `An update from PhotoComp!`;
                const message: string = `Please contact ${orgName}'s admin for more info.
                    In the meantime... You can check other organizations to apply to.`;
                const header: string = `Your membership application for ${orgName} has been denied!`;

                res.locals.user.emailInfo = { to, message, header, subject };
            }

            next(status);
        } catch (error) {
            next(error);
        }
    }
);
}

src/controllers/orgPhotoController.ts:
{
import { Request, Response, NextFunction, Router } from 'express';
import { PhotoService } from '../services/photoService';
import { AppError } from '../middleware/errorHandler';
import { checkOrgMember } from '../middleware/OrgMiddleware';

const photoService = new PhotoService();
export const orgPhotosRouter = Router({ mergeParams: true });

/**
 * Get all photos for an organization across all events
 * @route GET /organizations/:orgId/photos
 */
orgPhotosRouter.get(
    '/',
    checkOrgMember,
    async (req: Request, res: Response, next: NextFunction) => {
        try {
            const orgName: string = req.params.orgId;
            const user = res.locals.user.info;
            
            // Optional parameter to specify preferred image size
            const preferredSize = req.query.size as string || 'medium';
            
            const { photos, events } = await photoService.getAllOrganizationPhotos(
                orgName,
                user.id
            );

            // Add event information to each photo for the response
            const photosWithEventInfo = photos.map(photo => {
                const event = events.get(photo.eventId);
                
                // Determine the appropriate URL based on the requested size
                let displayUrl = photo.url; // Default to original URL for backward compatibility
                
                // Use the requested size if available
                if (photo.urls && photo.urls[preferredSize as keyof typeof photo.urls]) {
                    displayUrl = photo.urls[preferredSize as keyof typeof photo.urls] as string;
                } else if (photo.urls && photo.urls.original) {
                    // Fallback to original if the requested size is not available
                    displayUrl = photo.urls.original;
                }
                
                return {
                    ...photo,
                    displayUrl, // Add the chosen display URL
                    availableSizes: photo.urls ? Object.keys(photo.urls) : ['original'],
                    dimensions: photo.metadata ? {
                        width: photo.metadata.width,
                        height: photo.metadata.height
                    } : undefined,
                    event: event
                        ? {
                              id: event.id,
                              title: event.title,
                              date: event.date,
                          }
                        : null,
                };
            });

            return res.status(200).json({
                status: 'success',
                data: {
                    photos: photosWithEventInfo,
                    count: photos.length,
                    preferredSize,
                },
            });
        } catch (error) {
            next(error);
        }
    }
);}

src/controllers/photoController.ts:
{
import { Request, Response, NextFunction, Router } from 'express';
import { PhotoService } from '../services/photoService';
import { PhotoUploadRequest } from '../models/Photo';
import { checkOrgAdmin } from '../middleware/OrgMiddleware';
import { handleUpload } from '../middleware/uploadMiddleware';
import { AppError } from '../middleware/errorHandler';
import { v4 as uuidv4 } from 'uuid';

const photoService = new PhotoService();
export const photoRouter = Router({ mergeParams: true });

/**
 * Upload a photo to an event - enhanced to handle multiple files
 * POST /events/:eventId/photos
 */
photoRouter.post(
    '/',
    checkOrgAdmin,
    handleUpload('photo'),
    async (req: Request, res: Response, next: NextFunction) => {
        try {
            const eventId = req.params.eventId;
            const user = res.locals.user.info;

            // Check if any files were uploaded
            if (!req.file && !req.files) {
                throw new AppError('No photo file uploaded', 400);
            }

            // Handle single file upload case
            if (req.file) {
                const photoId = uuidv4();
                
                const photo = await photoService.uploadPhoto(
                    photoId,
                    eventId,
                    req.file.buffer,
                    req.file.mimetype,
                    user.id,
                    {
                        title: req.body.title,
                        description: req.body.description,
                        size: req.file.size,
                        mimeType: req.file.mimetype,
                    }
                );

                return res.status(201).json({
                    status: 'success',
                    data: {
                        photo,
                    },
                });
            } 
            // Handle multiple file upload case
            else if (req.files) {
                let files: Express.Multer.File[] = [];
                
                // Handle both array and object formats that Multer might return
                if (Array.isArray(req.files)) {
                    // If req.files is already an array of files
                    files = req.files;
                } else {
                    // If req.files is an object with fieldname keys
                    // Get the 'photo' field which contains our files
                    const photoFiles = req.files['photo'];
                    if (Array.isArray(photoFiles)) {
                        files = photoFiles;
                    }
                }
                
                if (files.length === 0) {
                    throw new AppError('No photo files found in upload', 400);
                }
                
                // Prepare arrays for batch processing
                const buffers: Buffer[] = [];
                const mimeTypes: string[] = [];
                
                files.forEach(file => {
                    buffers.push(file.buffer);
                    mimeTypes.push(file.mimetype);
                });
                
                const photos = await photoService.uploadPhoto(
                    null, // We'll generate IDs for each photo inside the service
                    eventId,
                    buffers,
                    mimeTypes,
                    user.id,
                    {
                        title: req.body.title,
                        description: req.body.description,
                    }
                );

                return res.status(201).json({
                    status: 'success',
                    data: {
                        photos, // Return array of photos when batch uploading
                    },
                });
            }
        } catch (error) {
            next(error);
        }
    }
);

/**
 * Get all photos for an event
 * GET /events/:eventId/photos
 */
photoRouter.get('/', async (req: Request, res: Response, next: NextFunction) => {
    try {
        const eventId = req.params.eventId;

        const photos = await photoService.getEventPhotos(eventId);

        return res.status(200).json({
            status: 'success',
            data: {
                photos,
            },
        });
    } catch (error) {
        next(error);
    }
});

/**
 * Get a download URL for a specific photo
 * GET /events/:eventId/photos/:photoId/download
 */
photoRouter.get('/:photoId/download', async (req: Request, res: Response, next: NextFunction) => {
    try {
        const eventId = req.params.eventId;
        const photoId = req.params.photoId;
        const user = res.locals.user.info;

        // Optional size parameter (defaults to 'original' if not provided)
        const size = req.query.size as 'original' | 'thumbnail' | 'medium' | 'large' || 'original';

        if (!['original', 'thumbnail', 'medium', 'large'].includes(size)) {
            throw new AppError('Invalid size parameter. Must be one of: original, thumbnail, medium, large', 400);
        }

        // Check if user has access to the event (is a member or admin)
        const canAccess = await photoService.validateUserEventAccess(eventId, user.id);

        if (!canAccess) {
            throw new AppError('You do not have access to photos from this event', 403);
        }

        // Generate download URL for the requested size
        const downloadUrl = await photoService.getPhotoDownloadUrl(photoId, eventId, size);

        return res.status(200).json({
            status: 'success',
            data: {
                downloadUrl,
                size,
            },
        });
    } catch (error) {
        next(error);
    }
});

/**
 * Delete a photo
 * DELETE /events/:eventId/photos/:photoId
 */
photoRouter.delete(
    '/:photoId',
    checkOrgAdmin,
    async (req: Request, res: Response, next: NextFunction) => {
        try {
            const photoId = req.params.photoId;
            const eventId = req.params.eventId;

            await photoService.deletePhoto(photoId, eventId);

            return res.status(200).json({
                status: 'success',
                message: 'Photo deleted successfully',
            });
        } catch (error) {
            next(error);
        }
    }
);}

src/controllers/photoTagsController.ts:
{
import { Request, Response, NextFunction, Router } from 'express';
import { TagService } from '../services/tagService';
import { OrgService } from '../services/orgService';
import { EventService } from '../services/eventService';
import { AppError } from '../middleware/errorHandler';
import { checkOrgAdmin, checkOrgMember } from '../middleware/OrgMiddleware';
import { emailSender } from '../middleware/emailSender';
import { TagRequest } from '../models/Tag';
import { Status } from '../models/Response';

const tagService = new TagService();
const orgService = new OrgService();
const eventService = new EventService();
export const photoTagsRouter = Router({ mergeParams: true });

/**
 * Get all users tagged in a photo
 * GET /organizations/:id/events/:eventId/photos/:photoId/tags
 */
photoTagsRouter.get('/', async (req: Request, res: Response, next: NextFunction) => {
    try {
        const photoId = req.params.photoId;

        const tags = await tagService.getPhotoTags(photoId);

        return res.status(200).json({
            status: 'success',
            data: {
                tags,
            },
        });
    } catch (error) {
        next(error);
    }
});

/**
 * Tag users in a photo
 * POST /organizations/:id/events/:eventId/photos/:photoId/tags
 */
photoTagsRouter.post(
    '/',
    checkOrgAdmin,
    async (req: Request, res: Response, next: NextFunction) => {
        try {
            const photoId = req.params.photoId;
            const eventId = req.params.eventId;
            const { userIds } = req.body;
            const admin = res.locals.user.info;

            if (!Array.isArray(userIds) || userIds.length === 0) {
                return res.status(400).json({
                    status: 'error',
                    message: 'A list of user IDs is required'
                });
            }

            const tagRequest: TagRequest = {
                userIds,
                photoId,
                eventId,
            };

            const tags = await tagService.tagUsersInPhoto(tagRequest, admin.id);
            console.log(tags);
            
            // Get event details for email
            const event = await eventService.findEventById(eventId);

            // Check if we should try to send emails
            if (event) {
                try {
                    const members = await orgService.getOrgMembers(event.GSI2PK.slice(4));
                    let membersEmail: string[] = [];

                    // Add email notification if members are tagged
                    if (members && members.length > 0) {
                        for (const tag of tags) {
                            for (const member of members) {
                                if (member.userId === tag.userId) {
                                    membersEmail.push(member.email);
                                }
                            }
                        }

                        // Only set up email if there are members to email
                        if (membersEmail.length > 0) {
                            // Creates the email data
                            const to: string = membersEmail.toString();
                            const subject: string = `An update from PhotoComp!`;
                            const message: string = `You have been tagged to a photo in the event ${event.title} in org ${event.GSI2PK.slice(4)}.
                            Know more by checking out the website!`;
                            const header: string = `You have been tagged in a photo!`;

                            // Initialize emailInfo if not exists
                            res.locals.user.emailInfo = { to, message, header, subject };
                            
                            // Create status object for email sender
                            const status: Status = {
                                statusCode: 201,
                                status: 'success',
                                message: `Tagged ${tags.length} users in photo`,
                                data: tags
                            };
                            
                            // Pass to email sender middleware
                            return emailSender(status, req, res, next);
                        }
                    }
                } catch (error) {
                    // If there's an error getting members, just continue to the success response
                    console.error('Error getting members for email notifications:', error);
                }
            }
            
            // Default response without email sending
            return res.status(201).json({
                status: 'success',
                message: `Tagged ${tags.length} users in photo`,
                data: {
                    tags
                }
            });
            
        } catch (error) {
            next(error);
        }
    }
);

/**
 * Remove a tag (untag a user from a photo)
 * DELETE /organizations/:id/events/:eventId/photos/:photoId/tags/:userId
 */
photoTagsRouter.delete(
    '/:userId',
    checkOrgAdmin,
    async (req: Request, res: Response, next: NextFunction) => {
        try {
            const photoId = req.params.photoId;
            const userId = req.params.userId;

            await tagService.removeTag(userId, photoId);

            return res.status(200).json({
                status: 'success',
                message: 'User untagged from photo successfully',
            });
        } catch (error) {
            next(error);
        }
    }
);

/**
 * Get all photos a user is tagged in
 * GET /users/:userId/tagged-photos
 */
export const getUserTaggedPhotos = async (req: Request, res: Response, next: NextFunction) => {
    try {
        const userId = req.params.userId;
        const requestingUserId = res.locals.user.id;

        // Users can only view their own tagged photos
        if (userId !== requestingUserId) {
            throw new AppError('You can only view your own tagged photos', 403);
        }

        const photos = await tagService.getUserTaggedPhotos(userId);

        return res.status(200).json({
            status: 'success',
            data: {
                photos,
                count: photos.length,
            },
        });
    } catch (error) {
        next(error);
    }
};}

src/controllers/userController.ts:
{
import { Request, Response, NextFunction, Router } from 'express';
import { getUserTaggedPhotos } from './photoTagsController';
import { getUserEvents } from './eventController';
import { AppError } from '../middleware/errorHandler';
import { authenticate } from '../middleware/authMiddleware';
import { OrgService } from '../services/orgService'

export const userRouter = Router();

// Apply authentication middleware to all user routes
userRouter.use(authenticate);

/**
 * Get all photos a user is tagged in
 * GET /users/:userId/tagged-photos
 */
userRouter.get('/:userId/tagged-photos', getUserTaggedPhotos);

/**
 * Get all events users is or has attended
 * @route GET /users/:userId/events
 */
userRouter.get('/:userId/events', getUserEvents);


/*
  * Check if the member is a part of the organization.
  * */
userRouter.get('/:userId/members/:orgId', async (req: Request, res: Response, next: NextFunction) => {
  try {
    console.log(req.params);
    const userId = req.params.userId;
    const orgId = req.params.orgId;
    const requestingUserId = res.locals.user.id;

    if (userId !== requestingUserId) {
      throw new AppError('You can only view your own membership information', 403);
    }

    const orgService = new OrgService();
    const userOrg = await orgService.findSpecificOrgByUser(orgId, userId);

    if (!userOrg) {
      return res.status(404).json({
        status: 'error',
        message: 'Membership not found',
      });
    }

    return res.status(200).json({
      status: 'success',
      data: {
        membership: userOrg,
      },
    });
  } catch (error) {
    next(error);
  }
});
}

src/index.ts:
{
import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import { authRouter } from './controllers/authController';
import { orgRouter } from './controllers/orgController';
import { errorHandler } from './middleware/errorHandler';
import { emailSender } from './middleware/emailSender';
import { loggerMethodMiddleware } from './middleware/loggerMiddleware';
import { eventRouter } from './controllers/eventController';
import { guestRouter } from './controllers/guestController';
import { photoRouter } from './controllers/photoController';
import { authenticate } from './middleware/authMiddleware';
import { orgMemberRouter } from './controllers/orgMemberController';
import { orgMembershipRouter } from './controllers/orgMemberShipController';
import { checkOrgMember, checkOrgAdmin, validateUserID } from './middleware/OrgMiddleware';
import { orgPhotosRouter } from './controllers/orgPhotoController';
import { photoTagsRouter } from './controllers/photoTagsController';
import { userRouter } from './controllers/userController';

// Load environment variables
dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json({ limit: '50mb' })); // Increased limit for photo uploads

// Super middleware
app.use(loggerMethodMiddleware);

// Routes
app.use('/api/auth', authRouter);
app.use('/guests', guestRouter);
app.use('/users', userRouter);

// Organizations base router that requires authentication
const organizationsRouter = express.Router();
app.use('/organizations', authenticate, validateUserID, organizationsRouter);

// Routes that all authenticated users can access
organizationsRouter.use('/', orgRouter);
organizationsRouter.use('/', orgMembershipRouter);

// Routes that all authenticated users can access where emailSender is used
organizationsRouter.use('/:id/requests/:userId', checkOrgAdmin, orgMembershipRouter, emailSender);

// Create a router specifically for protected org routes
const orgProtectedRouter = express.Router({ mergeParams: true });
// Add organization-level photos route
orgProtectedRouter.use('/photos', orgPhotosRouter);

organizationsRouter.use('/:orgId', checkOrgMember, orgProtectedRouter);

// Mount member-only routes
orgProtectedRouter.use('/events', eventRouter, emailSender);
orgProtectedRouter.use('/members', orgMemberRouter);
orgProtectedRouter.use(
    '/events/:eventId/photos',
    (req, res, next) => {
        // This ensures parameters are properly passed down to the photo controller
        next();
    },
    photoRouter
);

orgProtectedRouter.use(
    '/events/:eventId/photos/:photoId/tags',
    (req, res, next) => {
        // This ensures parameters are properly passed down to the photo tags controller
        next();
    },
    photoTagsRouter
);

// Default route
app.get('/', (req, res) => {
    res.send('PhotoComp API is running');
});

app.all(/(.*)/, (req, res, next) => {
    const error = new Error(`Not Found - ${req.originalUrl}`);
    res.status(404);
    next(error);
});

// Error handling and Email sending middleware must be used after all routes
//app.use(emailSender);
app.use(errorHandler);

// Start server
app.listen(PORT, () => {
    console.log(`Server running on port ${PORT} in ${process.env.NODE_ENV} mode`);
});
}

src/middleware/authMiddleware.ts:
{
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { UserRole } from '../models/User';
import { AppError } from './errorHandler';

export interface AuthRequest extends Request {
    user?: {
        id: string;
        email: string;
        role: UserRole;
    };
}

/**
 * Middleware to authenticate API requests
 * Verifies JWT token from Authorization header and adds decoded user to res.locals
 * Improved error handling to gracefully handle deleted users
 */
export const authenticate = (req: AuthRequest, res: Response, next: NextFunction) => {
    try {
        const authHeader = req.headers.authorization;

        if (!authHeader || !authHeader.startsWith('Bearer ')) {
            return next(new AppError('Authentication required', 401));
        }

        const token = authHeader.split(' ')[1];

        if (!token) {
            return next(new AppError('Authentication token missing', 401));
        }

        try {
            const decoded = jwt.verify(token, process.env.JWT_SECRET as string) as {
                id: string;
                email: string;
                role: UserRole;
            };

            // Store user info in res.locals for consistency
            res.locals.user = decoded;

            next();
        } catch (error) {
            // Handle JWT verification errors specifically
            if (error instanceof jwt.JsonWebTokenError) {
                return next(new AppError('Invalid token. Please log in again.', 401));
            } else if (error instanceof jwt.TokenExpiredError) {
                return next(new AppError('Your token has expired. Please log in again.', 401));
            }

            // Other unexpected errors
            return next(new AppError(`Authentication failed: ${(error as Error).message}`, 401));
        }
    } catch (error) {
        return next(new AppError(`Authentication failed: ${(error as Error).message}`, 401));
    }
};

/**
 * Middleware to verify admin role permissions
 * Must be used after authenticate middleware
 */
export const authorizeAdmin = (req: AuthRequest, res: Response, next: NextFunction) => {
    const user = res.locals.user;

    if (!user || user.role !== UserRole.ADMIN) {
        return next(new AppError('Access denied. Admin privileges required.', 403));
    }

    next();
};
}

src/middleware/emailSender.ts:
{
import { sendMail } from '../util/mailService';
import { Status } from '../models/Response';
import { Request, Response, NextFunction } from 'express';
import dotenv from 'dotenv';
import { logger } from '../util/logger';

dotenv.config();

export const emailSender = (status: Status | Error, req: Request, res: Response, next: NextFunction) => {
    // Handle case where status is an Error (pass it to next error handler)
    if (status instanceof Error) {
        return next(status);
    }
    
    // Ensure status has a valid statusCode
    if (!status || typeof status.statusCode !== 'number') {
        logger.error('Invalid status object or statusCode:', status);
        return res.status(500).json({
            status: 'error',
            message: 'Internal server error: Invalid status code'
        });
    }

    // Check if emailInfo exists
    if (!res.locals.user || !res.locals.user.emailInfo) {
        // If no email info is present, just return the status
        return res.status(status.statusCode).json({
            status: status.status,
            message: status.message || '',
            data: {
                tags: status.data
            }
        });
    }

    const { to, subject, message, header } = res.locals.user.emailInfo;
    
    // Validate all required email fields
    if (!to || !subject || !message || !header) {
        // If any required email field is missing, just return the status
        return res.status(status.statusCode).json({
            status: status.status,
            message: status.message || '',
            data: {
                tags: status.data
            }
        });
    }

    try {
        sendMail(to, subject, message, header);

        return res.status(status.statusCode).json({
            status: `${status.status} and email has been sent!`,
            message: status.message || '',
            data: {
                tags: status.data
            }
        });
    } catch (error) {
        next(error);
    }
};}

src/middleware/errorHandler.ts:
{
import { logger } from '../util/logger';
import { Request, Response, NextFunction } from 'express';

/**
 * Custom application error class
 * Extends Error with a status code for HTTP responses
 */
export class AppError extends Error {
    statusCode: number;

    constructor(message: string, statusCode: number) {
        super(message);
        this.statusCode = statusCode;

        // Capture stack trace for better debugging
        Error.captureStackTrace(this, this.constructor);
    }
}

/**
 * Global error handling middleware
 * Processes all errors passed to next() throughout the application
 */
export const errorHandler = (
    err: Error | AppError,
    req: Request,
    res: Response,
    next: NextFunction
): void => {
    // Log error for debugging purposes
    logger.error('Error:', err);

    // Handle AppError instances
    if (err instanceof AppError) {
        res.status(err.statusCode).json({
            status: 'error',
            message: err.message,
        });
        return;
    }

    // Handle specific errors from libraries
    if (err.name === 'ValidationError') {
        res.status(400).json({
            status: 'error',
            message: 'Validation failed: ' + err.message,
        });
        return;
    }

    if (err.name === 'JsonWebTokenError') {
        res.status(401).json({
            status: 'error',
            message: 'Invalid token. Please log in again.',
        });
        return;
    }

    if (err.name === 'TokenExpiredError') {
        res.status(401).json({
            status: 'error',
            message: 'Your token has expired. Please log in again.',
        });
        return;
    }

    // Default error response for unexpected errors
    const statusCode = res.statusCode !== 200 ? res.statusCode : 500;
    res.status(statusCode).json({
        status: 'error',
        message:
            process.env.NODE_ENV === 'production'
                ? 'Something went wrong'
                : err.message || 'Internal server error',
    });
};
}

src/middleware/loggerMiddleware.ts:
{
import { Request, Response, NextFunction } from 'express';
import { logger } from '../util/logger';

const loggerMethodMiddleware = (req: Request, res: Response, next: NextFunction): void => {
    logger.info(`Incoming ${req.method} : ${req.url}`);
    next();
};

export { loggerMethodMiddleware };
}

src/middleware/orgLogoUploadMiddleware.ts:
{
import multer from 'multer';
import { multerConfig } from '../config/multer';
import { AppError } from './errorHandler';
import { NextFunction, Request, Response } from 'express';

// File filter to validate image types for organization logos
const logoFileFilter = (
    req: Express.Request,
    file: Express.Multer.File,
    cb: multer.FileFilterCallback
) => {
    // Accept only image files
    if (file.mimetype.startsWith('image/')) {
        cb(null, true);
    } else {
        cb(new AppError('Only image files are allowed for logos', 400) as unknown as Error);
    }
};

// Create multer middleware with config and file filter
export const logoUploadMiddleware = multer({
    ...multerConfig,
    fileFilter: logoFileFilter,
});

// Create a wrapper middleware to handle multer errors
export const handleLogoUpload = (fieldName: string) => {
    return (req: Request, res: Response, next: NextFunction) => {
        const upload = logoUploadMiddleware.single(fieldName);
        console.log(`inside upload`);
        upload(req, res, err => {
            if (err) {
                if (err instanceof multer.MulterError) {
                    if (err.code === 'LIMIT_FILE_SIZE') {
                        return next(
                            new AppError('File size limit exceeded. Maximum size is 5MB', 400)
                        );
                    }
                    return next(new AppError(`Upload error: ${err.message}`, 400));
                }
                return next(err);
            }
            console.log(`before next`);
            next();
        });
    };
};}

src/middleware/OrgMiddleware.ts:
{
import { Request, Response, NextFunction } from 'express';
import { OrgService } from '../services/orgService';
import { AppError } from './errorHandler';
import { UserRole } from '../models/User';
import { UserOrganizationRelationship } from '../models/Organizations';
import { UserService } from '../services/userService';

const orgService = new OrgService();
const userService = new UserService();

export const checkOrgAdmin = async (req: Request, res: Response, next: NextFunction) => {
    try {
        // Check both possible parameter names
        const orgName: string = req.params.orgId || req.params.id;

        // Debug logging
        console.log(`Using organization name: "${orgName}" from params`);

        // Ensure we have an organization name
        if (!orgName) {
            return next(new AppError('Organization ID is missing in request parameters', 400));
        }

        const user = res.locals.user as { id: string; email: string; role: UserRole };

        const userAdminOrg: UserOrganizationRelationship | null =
            await orgService.findSpecificOrgByUser(orgName, user.id);

        if (!userAdminOrg) {
            return next(new AppError('You are not a member of this organization', 403));
        }

        if (!orgService.validateUserOrgAdmin(userAdminOrg)) {
            return next(
                new AppError(
                    'Only an Org Admin can perform this action. Please talk to your Admin for more information',
                    403
                )
            );
        }

        next();
    } catch (error) {
        next(error);
    }
};

export const checkOrgMember = async (req: Request, res: Response, next: NextFunction) => {
    try {
        const orgName: string = req.params.orgId || req.params.id;
        const user = res.locals.user as { id: string; email: string; role: UserRole };

        // console.log(`Checking organization membership for org: "${orgName}" and user: ${user.id}`);

        const userMemberOrg: UserOrganizationRelationship | null =
            await orgService.findSpecificOrgByUser(orgName, user.id);

        if (!orgService.validateUserOrgMember(userMemberOrg as UserOrganizationRelationship)) {
            return next(
                new AppError(
                    'Only an Org Member can perform this action. Please talk to the Admin for more information',
                    403
                )
            );
        }

        next();
    } catch (error) {
        next(error);
    }
};

export const validateUserID = async (req: Request, res: Response, next: NextFunction) => {
    try {
        const user = await userService.getUserByEmail(res.locals.user.email);

        if (!user) {
            return next(new AppError('User not found', 404));
        }

        res.locals.user.info = user;
        next();
    } catch (error) {
        return next(
            error instanceof AppError
                ? error
                : new AppError(`User validation failed: ${(error as Error).message}`, 500)
        );
    }
};
}

src/middleware/uploadMiddleware.ts:
{
import multer from 'multer';
import { multerConfig } from '../config/multer';
import { AppError } from './errorHandler';
import { NextFunction, Request, Response } from 'express';

// File filter to validate image types
const fileFilter = (
    req: Express.Request,
    file: Express.Multer.File,
    cb: multer.FileFilterCallback
) => {
    // Accept only image files
    if (file.mimetype.startsWith('image/')) {
        cb(null, true);
    } else {
        cb(new AppError('Only image files are allowed', 400) as unknown as Error);
    }
};

// Create multer middleware with config and file filter
export const uploadMiddleware = multer({
    ...multerConfig,
    fileFilter: fileFilter,
});

// Create a wrapper middleware to handle multer errors
export const handleUpload = (fieldName: string) => {
    return (req: Request, res: Response, next: NextFunction) => {
        // Check if there's a 'multiple' query parameter to determine upload type
        const isMultiple = req.query.multiple === 'true';
        
        let upload;
        if (isMultiple) {
            // For multiple file uploads - array allows multiple files with the same field name
            upload = uploadMiddleware.array(fieldName, 10); // Allow up to 10 files
        } else {
            // For single file uploads
            upload = uploadMiddleware.single(fieldName);
        }

        upload(req, res, (err: any) => {
            if (err) {
                if (err instanceof multer.MulterError) {
                    if (err.code === 'LIMIT_FILE_SIZE') {
                        return next(
                            new AppError('File size limit exceeded. Maximum size is 5MB', 400)
                        );
                    } else if (err.code === 'LIMIT_UNEXPECTED_FILE') {
                        return next(
                            new AppError('Too many files uploaded. Maximum is 10 files.', 400)
                        );
                    }
                    return next(new AppError(`Upload error: ${err.message}`, 400));
                }
                return next(err);
            }
            next();
        });
    };
};}

src/models/Event.ts:
{
// src/models/Event.ts
import { v4 as uuidv4 } from 'uuid';
import { WeatherData } from '../services/weatherService';

export interface Event {
    PK: string; // EVENT#<ID>
    SK: string;

    id: string;
    title: string;
    description: string;
    isPublic: boolean;
    date: string;
    createdAt: string;
    updatedAt: string;

    // Location fields
    location?: {
        name?: string;
        latitude: number;
        longitude: number;
    };

    // Weather data
    weather?: WeatherData;

    // GSI attributes
    GSI2PK: string; // ORG#<ID>
    GSI2SK: string; // EVENT#<ID>
}

export interface EventRequest {
    title: string;
    description: string;
    date: string;
    location?: {
        name?: string;
        latitude: number;
        longitude: number;
    };
    // New field for address string during event creation
    address?: string;
}

export interface EventUpdateRequest {
    title?: string;
    description?: string;
    date?: string;
    location?: {
        name?: string;
        latitude: number;
        longitude: number;
    };
    address?: string;
}

export interface EventUser {
    PK: string; // USER#<ID>
    SK: string; // EVENT#<ID>

    id: string;

    // GSI attributes
    GSI2PK: string; // EVENT#<ID>
    GSI2SK: string; // USER#<ID>
}

export const createEvent = (orgID: string, eventRequest: EventRequest): Event => {
    const id = uuidv4();
    const now = new Date().toISOString();
    const date = eventRequest.date || now;
    const eventId = `EVENT#${id}`;
    return {
        PK: eventId,
        SK: 'ENTITY',
        id: id,
        title: eventRequest.title,
        description: eventRequest.description,
        isPublic: true,
        date: date,
        createdAt: now,
        updatedAt: now,
        location: eventRequest.location,
        GSI2PK: `ORG#${orgID.toUpperCase()}`,
        GSI2SK: eventId,
    };
};

export const createEventUser = (userid: string, eventid: string): EventUser => {
    const userId = `USER#${userid}`;
    const eventId = `EVENT#${eventid}`;
    return {
        PK: userId,
        SK: eventId,
        id: eventid, // passed in eventid
        GSI2PK: eventId,
        GSI2SK: userId,
    };
};
}

src/models/Organizations.ts:
{
import { v4 as uuidv4 } from 'uuid';
import { UserRole } from './User';

export interface Organization {
    // Primary keys
    PK: string; // ORG#NAME
    SK: 'ENTITY'; // ENTITY

    // Attributes
    id: string;
    name: string;
    createdBy: string; // User ID of admin who created the organization
    createdAt: string;
    updatedAt: string;
    type: 'ORGANIZATION';
    isPublic: boolean;
    logoUrl: string;
    logoS3Key?: string;

    // Optional attributes
    description?: string;
    website?: string;
    contactEmail?: string;

    // GSI for finding organizations by creator
    GSI1PK?: string; // ORG
    GSI1SK?: string; // ORG#NAME
}

export interface OrganizationCreateRequest {
    name: string;
    description?: string;
    logoUrl: string;
    website?: string;
    contactEmail?: string;
    logoS3Key?: string; // Optional S3 key for the logo
}

export const createOrganization = (
    request: OrganizationCreateRequest,
    userId: string,
    logoS3Key?: string
): Organization => {
    const id = uuidv4();
    const now = new Date().toISOString();

    return {
        PK: `ORG#${request.name.toUpperCase()}`,
        SK: `ENTITY`,
        id,
        name: request.name,
        description: request.description,
        createdBy: userId,
        createdAt: now,
        updatedAt: now,
        type: 'ORGANIZATION',
        isPublic: true,
        logoUrl: request.logoUrl,
        logoS3Key: logoS3Key,
        website: request.website,
        contactEmail: request.contactEmail,
        GSI1PK: 'ORG',
        GSI1SK: `ORG#${request.name.toUpperCase()}`,
    };
};

// For updating an organization
export interface OrganizationUpdateRequest {
    name: string;
    description?: string;
    logoUrl?: string;
    website?: string;
    contactEmail?: string;
}

export const updateOrganization = (
    request: OrganizationUpdateRequest,
    org: Organization,
    logoS3Key?: string
): Organization => {
    const now = new Date().toISOString();
    return {
        PK: org.PK,
        SK: org.SK,
        id: org.id,
        name: org.name,
        description: request.description || org.description,
        createdBy: org.createdBy,
        createdAt: org.createdAt,
        updatedAt: now,
        type: `ORGANIZATION`,
        isPublic: org.isPublic,
        logoUrl: request.logoUrl || org.logoUrl,
        website: request.website || org.website,
        contactEmail: request.contactEmail || org.website,
        logoS3Key: logoS3Key || org.logoS3Key,
        GSI1PK: org.GSI1PK,
        GSI1SK: org.GSI1SK,
    };
};

// For creating the relationship between an organization and its admin
export interface UserOrganizationRelationship {
    PK: string; // USER#<userId>
    SK: string; // ORG#NAME
    userId: string;
    organizationName: string;
    role: UserRole;
    joinedAt: string;
    type: 'USER_ORG';
    email: string;

    // GSI for fetching all organizations a user belongs to
    GSI1PK?: string; // ORG#NAME
    GSI1SK?: string; // USER#<userId>
}

export const addOrganizationAdmin = (
    organizationName: string,
    userId: string,
    email: string
): UserOrganizationRelationship => {
    const now = new Date().toISOString();

    return {
        PK: `USER#${userId}`,
        SK: `ORG#${organizationName.toUpperCase()}`,
        userId,
        organizationName: organizationName,
        role: UserRole.ADMIN,
        joinedAt: now,
        type: 'USER_ORG',
        email,
        // Add GSI for querying all organizations a user belongs to
        GSI1PK: `ORG#${organizationName.toUpperCase()}`,
        GSI1SK: `USER#${userId}`,
    };
};

// For handling membership applications
export interface OrganizationMembershipRequest {
    PK: string; // ORG#NAME
    SK: string; // REQUEST#<userId>
    organizationName: string;
    userId: string;
    requestDate: string;
    message?: string;
    status: 'PENDING' | 'APPROVED' | 'DENIED';
    type: 'ORG_REQUEST';
    GSI1PK: string; // REQUEST#<userId>
    GSI1SK: string; // ORG#NAME
}

export const createOrganizationMembershipRequest = (
    organizationName: string,
    userId: string,
    message?: string
): OrganizationMembershipRequest => {
    const now = new Date().toISOString();

    return {
        PK: `ORG#${organizationName.toUpperCase()}`,
        SK: `REQUEST#${userId}`,
        organizationName,
        userId,
        requestDate: now,
        message,
        status: 'PENDING',
        type: 'ORG_REQUEST',
        GSI1PK: `REQUEST#${userId}`,
        GSI1SK: `ORG#${organizationName.toUpperCase()}`,
    };
};
}

src/models/Photo.ts:
{
import { v4 as uuidv4 } from 'uuid';

export interface PhotoSizes {
    original: string; // Original upload URL
    thumbnail?: string; // Small thumbnail (e.g., 200px width)
    medium?: string; // Medium size (e.g., 800px width)
    large?: string; // Large size (e.g., 1600px width)
}

export interface Photo {
    // Primary keys
    PK: string; // PHOTO#<PhotoID>
    SK: string; // ENTITY

    // Attributes
    id: string;
    eventId: string;
    url: string; // Original URL (kept for backwards compatibility)
    urls?: PhotoSizes; // New field containing all image size URLs
    createdAt: string;
    updatedAt: string;
    uploadedBy: string;

    // Optional metadata
    metadata?: {
        title?: string;
        description?: string;
        size?: number;
        width?: number;
        height?: number;
        mimeType?: string;
        s3Key?: string;
        s3Keys?: { // Store S3 keys for different sizes
            original?: string;
            thumbnail?: string;
            medium?: string;
            large?: string;
        };
    };

    // GSI for querying photos by event
    GSI2PK: string; // EVENT#<EventID>
    GSI2SK: string; // PHOTO#<PhotoID>
}

export interface PhotoUploadRequest {
    eventId: string;
    title?: string;
    description?: string;
}

export const createPhoto = (
    photoId: string,
    eventId: string,
    url: string,
    uploadedBy: string,
    urls?: PhotoSizes,
    metadata?: {
        title?: string;
        description?: string;
        size?: number;
        width?: number;
        height?: number;
        mimeType?: string;
        s3Key?: string;
        s3Keys?: {
            original?: string;
            thumbnail?: string;
            medium?: string;
            large?: string;
        };
    }
): Photo => {
    const now = new Date().toISOString();

    return {
        PK: `PHOTO#${photoId}`,
        SK: 'ENTITY',
        id: photoId,
        eventId,
        url, // Keep original url for backward compatibility
        urls, // Add new urls field for different sizes
        createdAt: now,
        updatedAt: now,
        uploadedBy,
        metadata,
        GSI2PK: `EVENT#${eventId}`,
        GSI2SK: `PHOTO#${photoId}`,
    };
};}

src/models/Response.ts:
{
export interface Status {
    statusCode: number;
    status: string;
    message?: string;
    data: object[];
}
}

src/models/Tag.ts:
{
import { v4 as uuidv4 } from 'uuid';

export interface Tag {
    // Primary keys
    PK: string; // TAG#<UserID>
    SK: string; // ENTITY

    // Attributes
    id: string;
    userId: string;
    photoId: string;
    eventId: string;
    taggedBy: string; // ID of the user who created the tag
    taggedAt: string; // ISO timestamp

    // GSI for querying tags by photo
    GSI1PK: string; // PHOTO#<PhotoID>
    GSI1SK: string; // TAG#<UserID>
}

export interface TagRequest {
    userIds: string[]; // Array of user IDs to tag
    photoId: string;
    eventId: string;
}

export const createTag = (
    userId: string,
    photoId: string,
    eventId: string,
    taggedBy: string
): Tag => {
    const id = uuidv4();
    const now = new Date().toISOString();

    return {
        PK: `TAG#${userId}`,
        SK: 'ENTITY',
        id,
        userId,
        photoId,
        eventId,
        taggedBy,
        taggedAt: now,
        GSI1PK: `PHOTO#${photoId}`,
        GSI1SK: `TAG#${userId}`,
    };
};
}

src/models/User.ts:
{
import { v4 as uuidv4 } from 'uuid';

export enum UserRole {
    USER = 'USER', // Default role for registered users
    MEMBER = 'MEMBER', // User who is part of an organization
    ADMIN = 'ADMIN', // User with admin privileges in an organization
}

export interface User {
    PK: string; // USER#<id>
    SK: 'ENTITY';
    id: string;
    email: string;
    firstName: string;
    lastName: string;
    password: string;
    role: UserRole;
    createdAt: string;
    updatedAt: string;
    type: 'USER';
    // GSI attributes
    GSI1PK?: string; // EMAIL#<email>
    GSI1SK?: 'ENTITY'; // ENTITY
}

export interface AuthRequest {
    email: string;
    password: string;
}

export interface RegisterRequest extends AuthRequest {
    firstName: string;
    lastName: string;
}

export interface PasswordChangeRequest {
    userId: string;
    currentPassword: string;
    newPassword: string;
}

export const createUserFromRegister = (registerRequest: RegisterRequest): User => {
    const id = uuidv4();
    const now = new Date().toISOString();

    return {
        PK: `USER#${id}`,
        SK: `ENTITY`,
        id,
        email: registerRequest.email,
        firstName: registerRequest.firstName,
        lastName: registerRequest.lastName,
        password: registerRequest.password,
        role: UserRole.USER, // Default role is USER
        createdAt: now,
        updatedAt: now,
        type: 'USER',
        // GSI for email lookups
        GSI1PK: `EMAIL#${registerRequest.email}`,
        GSI1SK: `ENTITY`,
    };
};}

src/repositories/eventRepository.ts:
{
import { dynamoDb, TABLE_NAME } from '../config/db';
import { Event, EventUser } from '../models/Event';
import {
    PutCommand,
    QueryCommand,
    GetCommand,
    DeleteCommand,
    UpdateCommand,
} from '@aws-sdk/lib-dynamodb';
import { QueryCommandOutput } from '@aws-sdk/client-dynamodb'; // Import this

import { AppError } from '../middleware/errorHandler';
import { WeatherData } from '@/services/weatherService';

/**
 * Repository class for handling event-related database operations.
 */
export class EventRepository {
    /**
     * Creates a new event in the database.
     *
     * @param event - The event object to be stored.
     * @returns The created event.
     * @throws {AppError} If the database operation fails.
     */
    async createOrgEvent(event: Event): Promise<Event> {
        try {
            await dynamoDb.send(
                new PutCommand({
                    TableName: TABLE_NAME,
                    Item: event,
                })
            );
            return event;
        } catch (error: any) {
            throw new AppError(`Failed to create event: ${error.message}`, 500);
        }
    }

    /**
     * Creates a record for a user attending an event.
     *
     * @param eventUser - The event attendance record to be stored.
     * @returns The created event attendance record.
     * @throws {AppError} If the database operation fails.
     */
    async addAttendingEventRecord(eventUser: EventUser): Promise<EventUser> {
        try {
            await dynamoDb.send(
                new PutCommand({
                    TableName: TABLE_NAME,
                    Item: eventUser,
                })
            );

            return eventUser;
        } catch (error: any) {
            throw new AppError(`Failed to add event attendance record: ${error.message}`, 500);
        }
    }

    /**
     * Removes a record for a user attending an event.
     *
     * @param eventUser - The event attendance record to be stored.
     * @returns True if successfull
     * @throws {AppError} If the database operation fails.
     */
    async removeAttendingEventRecord(userID: string, eventID: string): Promise<Boolean> {
        try {
            await dynamoDb.send(
                new DeleteCommand({
                    TableName: TABLE_NAME,
                    Key: {
                        PK: `USER#${userID}`,
                        SK: `EVENT#${eventID}`,
                    },
                })
            );

            return true;
        } catch (error: any) {
            throw new AppError(`Failed to add event attendance record: ${error.message}`, 500);
        }
    }

    /**
     * Retrieves all events for a specific organization.
     *
     * @param orgID - The ID of the organization.
     * @returns A list of events belonging to the organization.
     * @throws {AppError} If the database operation fails.
     */
    async getOrgEvents(orgID: string): Promise<Event[]> {
        try {
            // Query events using the GSI2 index, filtering by organization ID.
            const response = await dynamoDb.send(
                new QueryCommand({
                    TableName: TABLE_NAME,
                    IndexName: 'GSI2PK-GSI2SK-INDEX',
                    KeyConditionExpression: 'GSI2PK = :orgId AND begins_with(GSI2SK, :eventPrefix)',
                    ExpressionAttributeValues: {
                        ':orgId': `ORG#${orgID.toUpperCase()}`,
                        ':eventPrefix': `EVENT#`,
                    },
                })
            );
            // Use a safer type assertion
            return (response.Items as unknown as Event[]) || [];
        } catch (error: any) {
            throw new AppError(`Failed to retrieve events: ${error.message}`, 500);
        }
    }

    /**
     * Retrieves a specific event for an organization.
     *
     * @param orgID - The ID of the organization.
     * @param eventID - The ID of the event.
     * @returns The requested event.
     * @throws {AppError} If the database operation fails.
     */
    async getOrgEvent(orgID: string, eventID: string): Promise<Event> {
        try {
            // Query for a specific event using the GSI2 index.
            const response = await dynamoDb.send(
                new QueryCommand({
                    TableName: TABLE_NAME,
                    IndexName: 'GSI2PK-GSI2SK-INDEX',
                    KeyConditionExpression: 'GSI2PK = :orgID AND GSI2SK = :eventID',
                    ExpressionAttributeValues: {
                        ':orgID': `ORG#${orgID}`,
                        ':eventID': `EVENT#${eventID}`,
                    },
                })
            );

            const items = response.Items as Event[];
            // Use a safer type assertion
            return items[0] as unknown as Event; // Return the first (and expected only) result.
        } catch (error: any) {
            throw new AppError(`Failed to retrieve event: ${error.message}`, 500);
        }
    }

    /**
     * Retrieves all events that a specific user is attending.
     *
     * @param userID - The ID of the user.
     * @returns A list of events the user is attending.
     * @throws {AppError} If the database operation fails.
     */
    async getUserEvents(userID: string): Promise<Event[]> {
        try {
            // Query user-related events using their primary key.
            const response = await dynamoDb.send(
                new QueryCommand({
                    TableName: TABLE_NAME,
                    KeyConditionExpression: 'PK = :userPK AND begins_with(SK, :skPrefix)',
                    ExpressionAttributeValues: {
                        ':userPK': `USER#${userID}`,
                        ':skPrefix': 'EVENT#',
                    },
                })
            );
            // Use a safer type assertion
            return (response.Items as unknown as Event[]) || [];
        } catch (error: any) {
            throw new AppError(`Failed to retrieve user events: ${error.message}`, 500);
        }
    }

    /**
     * Retrieves all events for a specific organization.
     *
     * @param orgID - The ID of the organization.
     * @returns A list of events belonging to the organization.
     * @throws {AppError} If the database operation fails.
     */
    async getPublicOrgEvents(
        orgID: string
    ): Promise<{ events: Event[]; newLastEvaluatedKey: Record<string, any> | null }> {
        try {
            let publicEvents: Event[] = [];
            let lastEvaluatedKey: Record<string, any> | undefined = undefined;

            // Keep querying until we have at least 9 public events or no more data
            while (publicEvents.length < 9) {
                const response: any = await dynamoDb.send(
                    new QueryCommand({
                        TableName: TABLE_NAME,
                        IndexName: 'GSI2PK-GSI2SK-INDEX',
                        KeyConditionExpression:
                            'GSI2PK = :orgId AND begins_with(GSI2SK, :eventPrefix)',
                        ExpressionAttributeValues: {
                            ':orgId': `ORG#${orgID.toUpperCase()}`,
                            ':eventPrefix': `EVENT#`,
                        },
                        Limit: 15, // Fetch more events to ensure enough public ones
                        ExclusiveStartKey: lastEvaluatedKey || undefined,
                    })
                );

                // Use a safer type assertion
                const fetchedEvents = (response.Items as unknown as Event[]) || [];
                publicEvents.push(...fetchedEvents.filter(event => event.isPublic));

                // no more data to paginate
                if (!response.LastEvaluatedKey) break;

                lastEvaluatedKey = response.LastEvaluatedKey;
            }

            return {
                events: publicEvents.slice(0, 9),
                newLastEvaluatedKey: lastEvaluatedKey || null,
            };
        } catch (error: any) {
            throw new AppError(`Failed to retrieve events: ${error.message}`, 500);
        }
    }

    async findEventUserbyUser(eventId: string, userId: string): Promise<EventUser | null> {
        try {
            const params = {
                TableName: TABLE_NAME,
                Key: {
                    PK: `USER#${userId}`,
                    SK: `EVENT#${eventId}`,
                },
            };

            const result = await dynamoDb.send(new GetCommand(params));

            if (!result.Item) {
                return null;
            }
            // Use a safer type assertion
            return result.Item as unknown as EventUser;
        } catch (error: any) {
            throw new AppError(`Failed to find Event-User Connection: ${error.message}`, 500);
        }
    }

    async findEventById(eventId: string): Promise<Event | null> {
        try {
            const params = {
                TableName: TABLE_NAME,
                Key: {
                    PK: `EVENT#${eventId}`,
                    SK: `ENTITY`,
                },
            };

            const result = await dynamoDb.send(new GetCommand(params));

            if (!result.Item) {
                return null;
            }
            // Use a safer type assertion
            return result.Item as unknown as Event;
        } catch (error: any) {
            throw new AppError(`Failed to find Event: ${error.message}`, 500);
        }
    }

    async updateEventPublicity(event: Event): Promise<Event | null> {
        try {
            const updatedEvent = await dynamoDb.send(
                new UpdateCommand({
                    TableName: TABLE_NAME,
                    Key: {
                        PK: event.PK,
                        SK: event.SK,
                    },
                    UpdateExpression: 'SET #isPublic = :isPublic',
                    ExpressionAttributeNames: {
                        '#isPublic': 'isPublic',
                    },
                    ExpressionAttributeValues: {
                        ':isPublic': event.isPublic,
                    },
                    ReturnValues: 'ALL_NEW',
                })
            );

            if (!updatedEvent.Attributes) {
                throw new AppError('Event Publicity not updated', 400);
            }
            // Use a safer type assertion
            return updatedEvent.Attributes as unknown as Event;
        } catch (error: any) {
            throw new AppError(`Failed to update Event's Publicity: ${error.message}`, 500);
        }
    }

    async updateEvent(event: Event): Promise<Event> {
        try {
            await dynamoDb.send(
                new PutCommand({
                    TableName: TABLE_NAME,
                    Item: {
                        ...event,
                        updatedAt: new Date().toISOString(),
                    },
                })
            );

            return event;
        } catch (error: any) {
            throw new AppError(`Failed to update event: ${error.message}`, 500);
        }
    }

    /**
     * Updates weather data for an event
     * @param eventId The ID of the event
     * @param weatherData The weather data to add
     * @returns The updated event
     */
    async updateEventWeather(eventId: string, weatherData: WeatherData): Promise<Event> {
        try {
            const result = await dynamoDb.send(
                new UpdateCommand({
                    TableName: TABLE_NAME,
                    Key: {
                        PK: `EVENT#${eventId}`,
                        SK: 'ENTITY',
                    },
                    UpdateExpression: 'SET weather = :weatherData, updatedAt = :updatedAt',
                    ExpressionAttributeValues: {
                        ':weatherData': weatherData,
                        ':updatedAt': new Date().toISOString(),
                    },
                    ReturnValues: 'ALL_NEW',
                })
            );

            if (!result.Attributes) {
                throw new AppError(`Failed to update event weather data`, 500);
            }
            // Use a safer type assertion
            return result.Attributes as unknown as Event;
        } catch (error: any) {
            throw new AppError(`Failed to update event weather data: ${error.message}`, 500);
        }
    }

    /**
     * Gets all users attending an event, returning the full EventUser items.
     * @param eventId The event's ID
     * @returns Array of EventUser objects representing attendees.
     * @throws AppError if the database operation fails
     */
    async getEventAttendees(eventId: string): Promise<EventUser[]> {
        try {
            const response: QueryCommandOutput = await dynamoDb.send(
                new QueryCommand({
                    TableName: TABLE_NAME,
                    IndexName: 'GSI2PK-GSI2SK-INDEX',
                    KeyConditionExpression:
                        'GSI2PK = :eventId AND begins_with(GSI2SK, :userPrefix)',
                    ExpressionAttributeValues: {
                        ':eventId': `EVENT#${eventId}`,
                        ':userPrefix': 'USER#',
                    },
                    // Fetch all attributes
                    ProjectionExpression: undefined, // Ensure all attributes are fetched
                })
            );

            if (!response.Items || response.Items.length === 0) {
                return [];
            }

            // *** FIX: Use a safer type assertion ***
            return (response.Items as unknown as EventUser[]) || [];
        } catch (error: any) {
            throw new AppError(`Failed to get event attendees: ${error.message}`, 500);
        }
    }


    /**
 * Deletes an event from the database
 * @param eventId The ID of the event to delete
 * @returns True if the deletion was successful
 * @throws AppError if the database operation fails
 */
    async deleteEvent(eventId: string): Promise<boolean> {
        try {
            await dynamoDb.send(
                new DeleteCommand({
                    TableName: TABLE_NAME,
                    Key: {
                        PK: `EVENT#${eventId}`,
                        SK: 'ENTITY',
                    },
                })
            );
            return true;
        } catch (error: any) {
            throw new AppError(`Failed to delete event: ${error.message}`, 500);
        }
    }

    /**
     * Deletes all attendance records for an event
     * @param eventId The ID of the event
     * @returns True if the operation was successful
     * @throws AppError if the database operation fails
     */
    async deleteAllEventAttendance(eventId: string): Promise<boolean> {
        try {
            // First get all users attending the event
            const attendees = await this.getEventAttendees(eventId); // This now returns EventUser[]

            if (attendees.length === 0) {
                return true; // No attendance records to delete
            }

            // Delete each attendance record
            for (const attendee of attendees) {
                const userId = attendee.PK.split('#')[1]; // Extract user ID from PK
                await this.removeAttendingEventRecord(userId, eventId);
            }

            return true;
        } catch (error: any) {
            throw new AppError(`Failed to delete event attendance records: ${error.message}`, 500);
        }
    }
}
}

src/repositories/orgMembershipRepository.ts:
{
// Create a new repository file for handling organization membership requests
// src/repositories/orgMembershipRepository.ts

import { dynamoDb, TABLE_NAME } from '../config/db';
import { OrganizationMembershipRequest } from '../models/Organizations';
import { PutCommand, QueryCommand, DeleteCommand } from '@aws-sdk/lib-dynamodb';
import { AppError } from '../middleware/errorHandler';

export class OrgMembershipRepository {
    /**
     * Creates a new membership request in the database
     * @param request The membership request to create
     * @returns The created membership request
     */
    async createMembershipRequest(
        request: OrganizationMembershipRequest
    ): Promise<OrganizationMembershipRequest> {
        try {
            await dynamoDb.send(
                new PutCommand({
                    TableName: TABLE_NAME,
                    Item: request,
                    ConditionExpression: 'attribute_not_exists(PK) AND attribute_not_exists(SK)',
                })
            );
            return request;
        } catch (error: any) {
            if (error.name === 'ConditionalCheckFailedException') {
                throw new AppError(
                    'You have already submitted a request to join this organization',
                    409
                );
            }
            throw new AppError(`Failed to create membership request: ${error.message}`, 500);
        }
    }

    /**
     * Gets all pending membership requests for an organization
     * @param organizationName The name of the organization
     * @returns List of pending membership requests
     */
    async getPendingRequestsByOrganization(
        organizationName: string
    ): Promise<OrganizationMembershipRequest[]> {
        try {
            const result = await dynamoDb.send(
                new QueryCommand({
                    TableName: TABLE_NAME,
                    KeyConditionExpression: 'PK = :orgKey AND begins_with(SK, :requestPrefix)',
                    ExpressionAttributeValues: {
                        ':orgKey': `ORG#${organizationName.toUpperCase()}`,
                        ':requestPrefix': 'REQUEST#',
                    },
                })
            );

            return (result.Items || []) as OrganizationMembershipRequest[];
        } catch (error: any) {
            throw new AppError(`Failed to fetch membership requests: ${error.message}`, 500);
        }
    }

    /**
     * Deletes a membership request from the database
     * @param organizationName The name of the organization
     * @param userId The ID of the user whose request is being deleted
     * @returns True if successful, false otherwise
     */
    async deleteMembershipRequest(organizationName: string, userId: string): Promise<boolean> {
        try {
            await dynamoDb.send(
                new DeleteCommand({
                    TableName: TABLE_NAME,
                    Key: {
                        PK: `ORG#${organizationName.toUpperCase()}`,
                        SK: `REQUEST#${userId}`,
                    },
                })
            );
            return true;
        } catch (error: any) {
            throw new AppError(`Failed to delete membership request: ${error.message}`, 500);
        }
    }
}
}

src/repositories/orgRepository.ts:
{
import { dynamoDb, TABLE_NAME } from '../config/db';
import {
    Organization,
    OrganizationCreateRequest,
    UserOrganizationRelationship,
    OrganizationUpdateRequest,
    addOrganizationAdmin,
} from '../models/Organizations';

import {
    PutCommand,
    QueryCommand,
    GetCommand,
    DeleteCommand,
    UpdateCommand,
} from '@aws-sdk/lib-dynamodb';
import { AppError } from '../middleware/errorHandler';
import { UserRole } from '../models/User';
import { S3Service } from '../services/s3Service';
import { logger } from '../util/logger';

export class OrgRepository {
    private s3Service: S3Service;

    constructor() {
        this.s3Service = new S3Service();
    }

    async createOrg(org: Organization): Promise<OrganizationCreateRequest> {
        try {
            await dynamoDb.send(
                new PutCommand({
                    TableName: TABLE_NAME,
                    Item: org,
                    ConditionExpression: 'attribute_not_exists(PK)',
                })
            );

            return org;
        } catch (error: any) {
            if (error.name === 'ConditionalCheckFailedException') {
                throw new AppError('Organization already exists!', 409);
            }
            throw new AppError(`Failed to create Organization: ${error.message}`, 500);
        }
    }

    async createUserAdmin(
        userOrg: UserOrganizationRelationship
    ): Promise<UserOrganizationRelationship | null> {
        try {
            await dynamoDb.send(
                new PutCommand({
                    TableName: TABLE_NAME,
                    Item: userOrg,
                })
            );

            return userOrg;
        } catch (error: any) {
            throw new AppError(`Failed to create Organization: ${error.message}`, 500);
        }
    }

    async findOrgByName(name: string): Promise<Organization | null> {
        try {
            const params = {
                TableName: TABLE_NAME,
                Key: {
                    PK: `ORG#${name.toUpperCase()}`,
                    SK: `ENTITY`,
                },
            };

            const result = await dynamoDb.send(new GetCommand(params));

            if (!result.Item) {
                return null;
            }

            // Refresh the presigned URL for the logo if an S3 key exists
            const org = result.Item as Organization;
            if (org.logoS3Key) {
                try {
                    org.logoUrl = await this.s3Service.getLogoPreSignedUrl(org.logoS3Key);
                    logger.debug(`Refreshed logo URL for organization ${org.name}`);
                } catch (error) {
                    logger.error(`Error refreshing logo URL for org ${org.name}:`, error);
                    // If we can't generate a new URL, at least keep the existing one
                }
            }

            return org;
        } catch (error: any) {
            throw new AppError(`Failed to find organization by name: ${error.message}`, 500);
        }
    }

    async findSpecificOrgByUser(
        name: string,
        userId: string
    ): Promise<UserOrganizationRelationship | null> {
        try {
            const params = {
                TableName: TABLE_NAME,
                Key: {
                    PK: `USER#${userId}`,
                    SK: `ORG#${name.toUpperCase()}`,
                },
            };

            const result = await dynamoDb.send(new GetCommand(params));

            if (!result.Item) {
                return null;
            }

            return result.Item as UserOrganizationRelationship;
        } catch (error: any) {
            throw new AppError(`Failed to find organization by name: ${error.message}`, 500);
        }
    }

    async findOrgsByUser(userId: string): Promise<Organization[] | null> {
        try {
            const params = {
                TableName: TABLE_NAME,
                KeyConditionExpression: 'PK = :userIdKey and begins_with(SK, :orgName)',
                ExpressionAttributeValues: {
                    ':userIdKey': `USER#${userId}`,
                    ':orgName': `ORG#`,
                },
            };

            const result = await dynamoDb.send(new QueryCommand(params));

            if (!result.Items || result.Items.length === 0) {
                return [];
            }

            // Generate fresh pre-signed URLs for all organization logos
            const orgs = result.Items as Organization[];
            for (const org of orgs) {
                if (org.logoS3Key) {
                    try {
                        // Generate a new pre-signed URL for the logo
                        org.logoUrl = await this.s3Service.getLogoPreSignedUrl(org.logoS3Key);
                        logger.debug(`Refreshed logo URL for organization ${org.name} in findOrgsByUser`);
                    } catch (error) {
                        // Log the error but continue processing other organizations
                        logger.error(`Error refreshing logo URL for org ${org.name || org.id}:`, error);
                        // If we can't generate a new URL, at least keep the existing one
                    }
                }
            }

            return orgs;
        } catch (error: any) {
            throw new AppError(`Failed to find organization by id: ${error.message}`, 500);
        }
    }

    async updateOrgByName(org: Organization): Promise<OrganizationUpdateRequest | null> {
        try {
            const updateExpressions = [];
            const expressionAttributeNames: Record<string, string> = {};
            const expressionAttributeValues: Record<string, any> = {};
    
            if (org.description !== undefined && org.description.trim() !== '') {
                updateExpressions.push('#description = :description');
                expressionAttributeNames['#description'] = 'description';
                expressionAttributeValues[':description'] = org.description;
            }
    
            if (org.logoUrl !== undefined && org.logoUrl.trim() !== '') {
                updateExpressions.push('logoUrl = :logoUrl');
                expressionAttributeValues[':logoUrl'] = org.logoUrl;
            }
    
            if (org.website !== undefined && org.website.trim() !== '') {
                updateExpressions.push('website = :website');
                expressionAttributeValues[':website'] = org.website;
            }
    
            if (org.contactEmail !== undefined && org.contactEmail.trim() !== '') {
                updateExpressions.push('contactEmail = :contactEmail');
                expressionAttributeValues[':contactEmail'] = org.contactEmail;
            }
    
            if (updateExpressions.length === 0) {
                throw new AppError('No valid fields provided to update', 400);
            }
    
            const updatedOrg = await dynamoDb.send(
                new UpdateCommand({
                    TableName: TABLE_NAME,
                    Key: {
                        PK: org.PK,
                        SK: org.SK,
                    },
                    UpdateExpression: 'SET ' + updateExpressions.join(', '),
                    ExpressionAttributeNames: expressionAttributeNames,
                    ExpressionAttributeValues: expressionAttributeValues,
                    ReturnValues: 'ALL_NEW',
                })
            );
    
            if (!updatedOrg.Attributes) {
                throw new AppError('Organization not updated', 400);
            }
    
            return org;
        } catch (error: any) {
            throw new AppError(`Failed to update organization: ${error.message}`, 500);
        }
    }
    

    async findAllPublicOrgs(
    lastEvaluatedKey?: Record<string, any>
): Promise<{ orgs: Organization[]; newLastEvaluatedKey: Record<string, any> | null }> {
    try {
        const queryParams: any = {
            TableName: TABLE_NAME,
            IndexName: 'GSI1PK-GSI1SK-INDEX',
            KeyConditionExpression: 'GSI1PK = :orgKey and begins_with(GSI1SK, :orgName)',
            ExpressionAttributeValues: {
                ':orgKey': `ORG`,
                ':orgName': `ORG#`,
            },
            Limit: 9,
        };

        if (lastEvaluatedKey && 
            lastEvaluatedKey.PK && 
            lastEvaluatedKey.SK && 
            lastEvaluatedKey.GSI1PK && 
            lastEvaluatedKey.GSI1SK) {
            queryParams.ExclusiveStartKey = lastEvaluatedKey;
        }

        const result: any = await dynamoDb.send(new QueryCommand(queryParams));
        
        // Generate fresh presigned URLs for all organization logos
        const orgs = result.Items as Organization[];
        for (const org of orgs) {
            if (org.logoS3Key) {
                try {
                    // Generate a new pre-signed URL for the logo
                    org.logoUrl = await this.s3Service.getLogoPreSignedUrl(org.logoS3Key);
                    logger.debug(`Refreshed logo URL for organization ${org.name} in findAllPublicOrgs`);
                } catch (error) {
                    // Log the error but continue processing other organizations
                    logger.error(`Error refreshing logo URL for org ${org.name || org.id}:`, error);
                    // If we can't generate a new URL, at least keep the existing one
                }
            }
        }

        return {
            orgs: orgs,
            newLastEvaluatedKey: result.LastEvaluatedKey || null
        };
    } catch (error: any) {
        console.error("findAllPublicOrgs error:", error);
        throw new AppError(`Failed to find organizations: ${error.message}`, 500);
    }
}

    /**
     * Get all members of an organization
     * @param orgName The name of the organization
     * @returns Array of user-organization relationships
     */
    async getOrgMembers(orgName: string): Promise<UserOrganizationRelationship[]> {
        try {
            const result = await dynamoDb.send(
                new QueryCommand({
                    TableName: TABLE_NAME,
                    IndexName: 'GSI1PK-GSI1SK-INDEX',
                    KeyConditionExpression: 'GSI1PK = :orgKey AND begins_with(GSI1SK, :userPrefix)',
                    ExpressionAttributeValues: {
                        ':orgKey': `ORG#${orgName.toUpperCase()}`,
                        ':userPrefix': 'USER#',
                    },
                })
            );

            if (!result.Items || result.Items.length === 0) {
                return [];
            }

            return result.Items as UserOrganizationRelationship[];
        } catch (error: any) {
            throw new AppError(`Failed to get organization members: ${error.message}`, 500);
        }
    }

    /**
     * Remove a member from an organization
     * @param orgName The name of the organization
     * @param userId The ID of the user to remove
     * @returns True if successful
     */
    async removeMember(orgName: string, userId: string): Promise<boolean> {
        try {
            await dynamoDb.send(
                new DeleteCommand({
                    TableName: TABLE_NAME,
                    Key: {
                        PK: `USER#${userId}`,
                        SK: `ORG#${orgName.toUpperCase()}`,
                    },
                })
            );
            return true;
        } catch (error: any) {
            throw new AppError(`Failed to remove member: ${error.message}`, 500);
        }
    }

    /**
     * Update a member's role in an organization
     * @param orgName The name of the organization
     * @param userId The ID of the user to update
     * @param role The new role for the user
     * @returns The updated user-organization relationship
     */
    async updateMemberRole(
        orgName: string,
        userId: string,
        role: UserRole
    ): Promise<UserOrganizationRelationship> {
        try {
            const now = new Date().toISOString();

            const result = await dynamoDb.send(
                new UpdateCommand({
                    TableName: TABLE_NAME,
                    Key: {
                        PK: `USER#${userId}`,
                        SK: `ORG#${orgName.toUpperCase()}`,
                    },
                    UpdateExpression: 'SET #role = :role, updatedAt = :updatedAt',
                    ExpressionAttributeNames: {
                        '#role': 'role',
                    },
                    ExpressionAttributeValues: {
                        ':role': role,
                        ':updatedAt': now,
                    },
                    ReturnValues: 'ALL_NEW',
                })
            );

            if (!result.Attributes) {
                throw new AppError('Member not found', 404);
            }

            return result.Attributes as UserOrganizationRelationship;
        } catch (error: any) {
            throw new AppError(`Failed to update member role: ${error.message}`, 500);
        }
    }
}}

src/repositories/photoRepository.ts:
{
import { dynamoDb, TABLE_NAME } from '../config/db';
import { Photo } from '../models/Photo';
import { PutCommand, QueryCommand, GetCommand, DeleteCommand } from '@aws-sdk/lib-dynamodb';
import { AppError } from '../middleware/errorHandler';

export class PhotoRepository {
    /**
     * Creates a new photo record in the database
     * @param photo The photo object to create
     * @returns The created photo
     * @throws AppError if the operation fails
     */
    async createPhoto(photo: Photo): Promise<Photo> {
        try {
            await dynamoDb.send(
                new PutCommand({
                    TableName: TABLE_NAME,
                    Item: photo,
                })
            );
            return photo;
        } catch (error: any) {
            throw new AppError(`Failed to create photo record: ${error.message}`, 500);
        }
    }

    /**
     * Retrieves a photo by its ID
     * @param photoId The ID of the photo to retrieve
     * @returns The photo record or null if not found
     * @throws AppError if the operation fails
     */
    async getPhotoById(photoId: string): Promise<Photo | null> {
        try {
            const result = await dynamoDb.send(
                new GetCommand({
                    TableName: TABLE_NAME,
                    Key: {
                        PK: `PHOTO#${photoId}`,
                        SK: 'ENTITY',
                    },
                })
            );

            if (!result.Item) {
                return null;
            }

            return result.Item as Photo;
        } catch (error: any) {
            throw new AppError(`Failed to retrieve photo: ${error.message}`, 500);
        }
    }

    /**
     * Retrieves all photos for a specific event
     * @param eventId The ID of the event
     * @returns A list of photos for the event
     * @throws AppError if the operation fails
     */
    async getPhotosByEvent(eventId: string): Promise<Photo[]> {
        try {
            const response = await dynamoDb.send(
                new QueryCommand({
                    TableName: TABLE_NAME,
                    IndexName: 'GSI2PK-GSI2SK-INDEX',
                    KeyConditionExpression:
                        'GSI2PK = :eventId AND begins_with(GSI2SK, :photoPrefix)',
                    ExpressionAttributeValues: {
                        ':eventId': `EVENT#${eventId}`,
                        ':photoPrefix': 'PHOTO#',
                    },
                })
            );

            // Ensure we always return an array, even if Items is undefined
            return (response.Items || []) as Photo[];
        } catch (error: any) {
            throw new AppError(`Failed to retrieve event photos: ${error.message}`, 500);
        }
    }

    /**
     * Deletes a photo from the database
     * @param photoId The ID of the photo to delete
     * @throws AppError if the operation fails
     */
    async deletePhoto(photoId: string): Promise<void> {
        try {
            await dynamoDb.send(
                new DeleteCommand({
                    TableName: TABLE_NAME,
                    Key: {
                        PK: `PHOTO#${photoId}`,
                        SK: 'ENTITY',
                    },
                })
            );
        } catch (error: any) {
            throw new AppError(`Failed to delete photo: ${error.message}`, 500);
        }
    }
}
}

src/repositories/s3Repository.ts:
{
import { s3Client, getSignedUrl, S3_BUCKET_NAME } from '../config/s3';
import { PutObjectCommand, GetObjectCommand, DeleteObjectCommand } from '@aws-sdk/client-s3';
import { AppError } from '../middleware/errorHandler';
import { logger } from '../util/logger';

export class S3Repository {
    /**
     * Uploads a file to S3 from buffer data
     * @param fileBuffer The buffer containing file data
     * @param key The S3 key where the file will be stored
     * @param contentType The content type of the file
     * @returns The S3 key where the file was uploaded
     */
    async uploadFile(fileBuffer: Buffer, key: string, contentType: string): Promise<string> {
        try {
            const command = new PutObjectCommand({
                Bucket: S3_BUCKET_NAME,
                Key: key,
                Body: fileBuffer,
                ContentType: contentType,
            });

            await s3Client.send(command);
            logger.info(`Uploaded file to S3: ${key}`);

            return key;
        } catch (error) {
            logger.error('Error uploading file to S3:', error);
            throw new AppError(`Failed to upload file to S3: ${(error as Error).message}`, 500);
        }
    }

    /**
     * Uploads multiple files to S3
     * @param files Object containing buffers with their corresponding keys and content types
     * @returns Object with the uploaded keys
     */
    async uploadMultipleFiles(
        files: Array<{
            buffer: Buffer;
            key: string;
            contentType: string;
        }>
    ): Promise<string[]> {
        try {
            const uploadPromises = files.map(file =>
                this.uploadFile(file.buffer, file.key, file.contentType)
            );
            
            const results = await Promise.all(uploadPromises);
            logger.info(`Uploaded ${results.length} files to S3`);
            
            return results;
        } catch (error) {
            logger.error('Error uploading multiple files to S3:', error);
            throw new AppError(`Failed to upload multiple files to S3: ${(error as Error).message}`, 500);
        }
    }

    /**
     * Generates a pre-signed URL for accessing an S3 object
     * @param key The S3 key of the object
     * @param expiresIn The expiration time in seconds (default: 604800 = 7 days, the maximum)
     * @returns The pre-signed URL
     */
    async getPreSignedUrl(key: string, expiresIn: number = 604800): Promise<string> {
        try {
            const command = new GetObjectCommand({
                Bucket: S3_BUCKET_NAME,
                Key: key,
            });

            const presignedUrl = await getSignedUrl(s3Client, command, { expiresIn });
            return presignedUrl;
        } catch (error) {
            logger.error('Error generating pre-signed URL:', error);
            throw new AppError(
                `Failed to generate pre-signed URL: ${(error as Error).message}`,
                500
            );
        }
    }

    /**
     * Generates multiple pre-signed URLs for accessing S3 objects
     * @param keys Array of S3 keys
     * @param expiresIn The expiration time in seconds (default: 604800 = 7 days, the maximum)
     * @returns Object mapping keys to their pre-signed URLs
     */
    async getMultiplePreSignedUrls(
        keys: string[],
        expiresIn: number = 604800
    ): Promise<Record<string, string>> {
        try {
            const urlPromises = keys.map(async key => ({
                key,
                url: await this.getPreSignedUrl(key, expiresIn),
            }));
            
            const results = await Promise.all(urlPromises);
            
            // Convert array of results to object mapping
            const urlMap: Record<string, string> = {};
            for (const result of results) {
                urlMap[result.key] = result.url;
            }
            
            return urlMap;
        } catch (error) {
            logger.error('Error generating multiple pre-signed URLs:', error);
            throw new AppError(
                `Failed to generate multiple pre-signed URLs: ${(error as Error).message}`,
                500
            );
        }
    }

    /**
     * Generates a pre-signed URL for downloading an S3 object with a specific filename
     * @param key The S3 key of the object
     * @param filename The suggested filename for the download
     * @param expiresIn The expiration time in seconds (default: 604800 = 7 days, the maximum)
     * @returns The pre-signed URL with content-disposition header set
     */
    async getDownloadPreSignedUrl(
        key: string,
        filename: string,
        expiresIn: number = 604800
    ): Promise<string> {
        try {
            const command = new GetObjectCommand({
                Bucket: S3_BUCKET_NAME,
                Key: key,
                ResponseContentDisposition: `attachment; filename="${encodeURIComponent(filename)}"`,
            });

            const presignedUrl = await getSignedUrl(s3Client, command, { expiresIn });
            return presignedUrl;
        } catch (error) {
            logger.error('Error generating download pre-signed URL:', error);
            throw new AppError(
                `Failed to generate download pre-signed URL: ${(error as Error).message}`,
                500
            );
        }
    }

    /**
     * Deletes a file from S3
     * @param key The S3 key of the object to delete
     */
    async deleteFile(key: string): Promise<void> {
        try {
            const command = new DeleteObjectCommand({
                Bucket: S3_BUCKET_NAME,
                Key: key,
            });

            await s3Client.send(command);
            logger.info(`Deleted file from S3: ${key}`);
        } catch (error) {
            logger.error('Error deleting file from S3:', error);
            throw new AppError(`Failed to delete file from S3: ${(error as Error).message}`, 500);
        }
    }

    /**
     * Deletes multiple files from S3
     * @param keys Array of S3 keys to delete
     */
    async deleteMultipleFiles(keys: string[]): Promise<void> {
        try {
            const deletePromises = keys.map(key => this.deleteFile(key));
            await Promise.all(deletePromises);
            logger.info(`Deleted ${keys.length} files from S3`);
        } catch (error) {
            logger.error('Error deleting multiple files from S3:', error);
            throw new AppError(
                `Failed to delete multiple files from S3: ${(error as Error).message}`,
                500
            );
        }
    }
}}

src/repositories/tagRepository.ts:
{
import { dynamoDb, TABLE_NAME } from '../config/db';
import { Tag } from '../models/Tag';
import {
    PutCommand,
    QueryCommand,
    GetCommand,
    DeleteCommand,
    BatchWriteCommand,
} from '@aws-sdk/lib-dynamodb';
import { AppError } from '../middleware/errorHandler';
import { logger } from '../util/logger';

export class TagRepository {
    /**
     * Creates a new tag in the database
     * @param tag The tag to create
     * @returns The created tag
     */
    async createTag(tag: Tag): Promise<Tag> {
        try {
            await dynamoDb.send(
                new PutCommand({
                    TableName: TABLE_NAME,
                    Item: tag,
                    // Add a conditional expression to prevent duplicates
                    ConditionExpression: 'attribute_not_exists(PK) AND attribute_not_exists(SK)',
                })
            );
            return tag;
        } catch (error: any) {
            if (error.name === 'ConditionalCheckFailedException') {
                throw new AppError('User is already tagged in this photo', 409);
            }
            throw new AppError(`Failed to create tag: ${error.message}`, 500);
        }
    }

    /**
     * Creates multiple tags in a batch operation
     * @param tags Array of tags to create
     * @returns True if successful
     */
    async batchCreateTags(tags: Tag[]): Promise<boolean> {
        try {
            // DynamoDB batch operations have a limit of 25 items
            const chunks: Tag[][] = [];
            for (let i = 0; i < tags.length; i += 25) {
                chunks.push(tags.slice(i, i + 25));
            }

            // Process each chunk
            for (const chunk of chunks) {
                const putRequests = chunk.map(tag => ({
                    PutRequest: {
                        Item: tag,
                    },
                }));

                const params = {
                    RequestItems: {
                        [TABLE_NAME as string]: putRequests,
                    },
                };

                await dynamoDb.send(new BatchWriteCommand(params));
            }

            return true;
        } catch (error: any) {
            logger.error('Error creating batch tags:', error);
            throw new AppError(`Failed to create tags in batch: ${error.message}`, 500);
        }
    }

    /**
     * Retrieves all photos a user is tagged in
     * @param userId The user's ID
     * @returns Array of tags containing photo information
     */
    async getTagsByUser(userId: string): Promise<Tag[]> {
        try {
            const response = await dynamoDb.send(
                new QueryCommand({
                    TableName: TABLE_NAME,
                    KeyConditionExpression: 'PK = :pk AND SK = :sk',
                    ExpressionAttributeValues: {
                        ':pk': `TAG#${userId}`,
                        ':sk': 'ENTITY',
                    },
                })
            );

            return (response.Items || []) as Tag[];
        } catch (error: any) {
            logger.error('Error getting user tags:', error);
            throw new AppError(`Failed to retrieve user tags: ${error.message}`, 500);
        }
    }

    /**
     * Retrieves all users tagged in a photo
     * @param photoId The photo's ID
     * @returns Array of tags containing user information
     */
    async getTagsByPhoto(photoId: string): Promise<Tag[]> {
        try {
            const response = await dynamoDb.send(
                new QueryCommand({
                    TableName: TABLE_NAME,
                    IndexName: 'GSI1PK-GSI1SK-INDEX',
                    KeyConditionExpression: 'GSI1PK = :pk',
                    ExpressionAttributeValues: {
                        ':pk': `PHOTO#${photoId}`,
                    },
                })
            );

            return (response.Items || []) as Tag[];
        } catch (error: any) {
            logger.error('Error getting photo tags:', error);
            throw new AppError(`Failed to retrieve photo tags: ${error.message}`, 500);
        }
    }

    /**
     * Deletes a tag (removes a user from a photo)
     * @param userId The user's ID
     * @param photoId The photo's ID
     * @returns True if successful
     */
    async deleteTag(userId: string): Promise<boolean> {
        try {
            await dynamoDb.send(
                new DeleteCommand({
                    TableName: TABLE_NAME,
                    Key: {
                        PK: `TAG#${userId}`,
                        SK: 'ENTITY',
                    },
                })
            );
            return true;
        } catch (error: any) {
            logger.error('Error deleting tag:', error);
            throw new AppError(`Failed to delete tag: ${error.message}`, 500);
        }
    }

    /**
     * Checks if a tag exists for a user and photo
     * @param userId The user's ID
     * @param photoId The photo's ID
     * @returns The tag if it exists, null otherwise
     */
    async getTagByUserAndPhoto(userId: string, photoId: string): Promise<Tag | null> {
        try {
            // First get the tag by user ID
            const userTag = await dynamoDb.send(
                new GetCommand({
                    TableName: TABLE_NAME,
                    Key: {
                        PK: `TAG#${userId}`,
                        SK: 'ENTITY',
                    },
                })
            );

            // Return null if no tag exists
            if (!userTag.Item) {
                return null;
            }

            const tag = userTag.Item as Tag;

            // Check if this tag is for the specified photo
            if (tag.photoId === photoId) {
                return tag;
            }

            return null;
        } catch (error: any) {
            logger.error('Error checking tag existence:', error);
            throw new AppError(`Failed to check tag existence: ${error.message}`, 500);
        }
    }
}
}

src/repositories/userRepository.ts:
{
import { AppError } from '../middleware/errorHandler';
import { dynamoDb, TABLE_NAME } from '../config/db';
import { User, UserRole } from '../models/User';
import {
    PutCommand,
    QueryCommand,
    GetCommand,
    BatchWriteCommand,
    DeleteCommand,
    UpdateCommand,
} from '@aws-sdk/lib-dynamodb';

/**
 * Repository class for User-related database operations
 * Handles CRUD operations for user data in DynamoDB
 */
export class UserRepository {
    /**
     * Create a new user in the database
     * @param user The user object to create
     * @returns The created user
     * @throws AppError if user already exists or operation fails
     */
    async createUser(user: User): Promise<User> {
        try {
            await dynamoDb.send(
                new PutCommand({
                    TableName: TABLE_NAME,
                    Item: user,
                    ConditionExpression: 'attribute_not_exists(PK)',
                })
            );
            return user;
        } catch (error: any) {
            if (error.name === 'ConditionalCheckFailedException') {
                throw new AppError('User already exists', 409);
            }
            throw new AppError(`Failed to create user: ${error.message}`, 500);
        }
    }

    /**
     * Find a user by email address
     * @param email Email address to search for
     * @returns The user object or null if not found
     * @throws AppError if operation fails
     */
    async findUserByEmail(email: string): Promise<User | null> {
        try {
            const params = {
                TableName: TABLE_NAME,
                IndexName: 'GSI1PK-GSI1SK-INDEX',
                KeyConditionExpression: 'GSI1PK = :emailKey AND GSI1SK = :entityValue',
                ExpressionAttributeValues: {
                    ':emailKey': `EMAIL#${email}`,
                    ':entityValue': 'ENTITY',
                },
            };

            const result = await dynamoDb.send(new QueryCommand(params));

            if (!result.Items || result.Items.length === 0) {
                return null;
            }

            return result.Items[0] as User;
        } catch (error: any) {
            throw new AppError(`Failed to find user by email: ${error.message}`, 500);
        }
    }

    /**
     * Get a user by their ID
     * @param userId The user ID to look up
     * @returns The user object or null if not found
     * @throws AppError if operation fails
     */
    async getUserById(userId: string): Promise<User | null> {
        try {
            const result = await dynamoDb.send(
                new GetCommand({
                    TableName: TABLE_NAME,
                    Key: {
                        PK: `USER#${userId}`,
                        SK: `ENTITY`,
                    },
                })
            );

            if (!result.Item) {
                return null;
            }

            return result.Item as User;
        } catch (error: any) {
            throw new AppError(`Failed to get user by ID: ${error.message}`, 500);
        }
    }

    /**
     * Update a user's password
     * @param userId The ID of the user
     * @param newPassword The new hashed password
     * @returns Boolean indicating success
     * @throws AppError if operation fails
     */
    async updateUserPassword(userId: string, newPassword: string): Promise<boolean> {
        try {
            const now = new Date().toISOString();
            
            const result = await dynamoDb.send(
                new UpdateCommand({
                    TableName: TABLE_NAME,
                    Key: {
                        PK: `USER#${userId}`,
                        SK: 'ENTITY',
                    },
                    UpdateExpression: 'SET #password = :password, updatedAt = :updatedAt',
                    ExpressionAttributeNames: {
                        '#password': 'password',
                    },
                    ExpressionAttributeValues: {
                        ':password': newPassword,
                        ':updatedAt': now,
                    },
                    ReturnValues: 'UPDATED_NEW',
                })
            );

            if (!result.Attributes) {
                throw new AppError('Failed to update password', 500);
            }

            return true;
        } catch (error: any) {
            throw new AppError(`Failed to update password: ${error.message}`, 500);
        }
    }

    /**
     * Delete a user from the database
     * @param userId The ID of the user to delete
     * @returns True if successful
     * @throws AppError if operation fails
     */
    async deleteUser(userId: string): Promise<boolean> {
        try {
            // First check if the user exists
            const user = await this.getUserById(userId);
            if (!user) {
                throw new AppError('User not found', 404);
            }

            // Delete the user record using DeleteCommand
            await dynamoDb.send(
                new DeleteCommand({
                    TableName: TABLE_NAME,
                    Key: {
                        PK: `USER#${userId}`,
                        SK: 'ENTITY',
                    },
                })
            );

            // If the user has an email (they should), delete the GSI record too
            if (user.email) {
                await dynamoDb.send(
                    new DeleteCommand({
                        TableName: TABLE_NAME,
                        Key: {
                            PK: `EMAIL#${user.email}`,
                            SK: 'ENTITY',
                        },
                    })
                );
            }

            return true;
        } catch (error: any) {
            throw new AppError(`Failed to delete user: ${error.message}`, 500);
        }
    }

    /**
     * Delete all organization memberships for a user
     * @param userId The ID of the user
     * @returns True if successful
     * @throws AppError if operation fails
     */
    async deleteUserOrganizationMemberships(userId: string): Promise<boolean> {
        try {
            // Make sure TABLE_NAME is defined
            if (!TABLE_NAME) {
                throw new AppError('Table name not configured', 500);
            }

            // First get all organizations the user is a member of
            const params = {
                TableName: TABLE_NAME,
                KeyConditionExpression: 'PK = :userId AND begins_with(SK, :orgPrefix)',
                ExpressionAttributeValues: {
                    ':userId': `USER#${userId}`,
                    ':orgPrefix': 'ORG#',
                },
            };

            const result = await dynamoDb.send(new QueryCommand(params));

            // No memberships found - consider it a success
            if (!result.Items || result.Items.length === 0) {
                return true;
            }

            // Prepare batch request for delete - DynamoDB can handle 25 at a time
            const chunks = [];
            for (let i = 0; i < result.Items.length; i += 25) {
                chunks.push(result.Items.slice(i, i + 25));
            }

            // Process each chunk as a batch
            for (const chunk of chunks) {
                const deleteRequests = chunk.map(item => ({
                    DeleteRequest: {
                        Key: {
                            PK: item.PK,
                            SK: item.SK,
                        },
                    },
                }));

                const requestItems: Record<string, any> = {};
                requestItems[TABLE_NAME] = deleteRequests;

                await dynamoDb.send(
                    new BatchWriteCommand({
                        RequestItems: requestItems,
                    })
                );
            }

            return true;
        } catch (error: any) {
            throw new AppError(`Failed to delete user memberships: ${error.message}`, 500);
        }
    }

    /**
     * Delete all event attendance records for a user
     * @param userId The ID of the user
     * @returns True if successful
     * @throws AppError if operation fails
     */
    async deleteUserEventAttendance(userId: string): Promise<boolean> {
        try {
            // Make sure TABLE_NAME is defined
            if (!TABLE_NAME) {
                throw new AppError('Table name not configured', 500);
            }

            // First get all events the user is attending
            const params = {
                TableName: TABLE_NAME,
                KeyConditionExpression: 'PK = :userId AND begins_with(SK, :eventPrefix)',
                ExpressionAttributeValues: {
                    ':userId': `USER#${userId}`,
                    ':eventPrefix': 'EVENT#',
                },
            };

            const result = await dynamoDb.send(new QueryCommand(params));

            // No event attendance records found - consider it a success
            if (!result.Items || result.Items.length === 0) {
                return true;
            }

            // Prepare batch request for delete - DynamoDB can handle 25 at a time
            const chunks = [];
            for (let i = 0; i < result.Items.length; i += 25) {
                chunks.push(result.Items.slice(i, i + 25));
            }

            // Process each chunk as a batch
            for (const chunk of chunks) {
                const deleteRequests = chunk.map(item => ({
                    DeleteRequest: {
                        Key: {
                            PK: item.PK,
                            SK: item.SK,
                        },
                    },
                }));

                const requestItems: Record<string, any> = {};
                requestItems[TABLE_NAME] = deleteRequests;

                await dynamoDb.send(
                    new BatchWriteCommand({
                        RequestItems: requestItems,
                    })
                );
            }

            return true;
        } catch (error: any) {
            throw new AppError(
                `Failed to delete user event attendance records: ${error.message}`,
                500
            );
        }
    }
}}

src/services/eventService.ts:
{
import { EventRepository } from '../repositories/eventRepository';
import { Event, EventRequest, EventUser, createEvent, createEventUser } from '../models/Event';
import { AppError } from '../middleware/errorHandler';
import { WeatherData, WeatherService } from './weatherService';
import { GeocodingService } from './geocodingService';
import { logger } from '../util/logger';
import { PhotoRepository } from '../repositories/photoRepository';
import { S3Service } from './s3Service';
import { TagRepository } from '../repositories/tagRepository';

/**
 * Service class for handling event-related operations including CRUD operations,
 * user-event relationships, and weather data integration.
 */
export class EventService {
    private eventRepository: EventRepository;
    private weatherService: WeatherService;
    private geocodingService: GeocodingService;

    /**
     * Initializes the EventService with repository and service dependencies
     *
     * @param eventRepository - Handles database operations for events
     * @param weatherService - Provides weather forecast data from Open-Meteo API
     * @param geocodingService - Provides geocoding services to convert addresses to coordinates
     */
    constructor(
        eventRepository: EventRepository = new EventRepository(),
        weatherService: WeatherService = new WeatherService(),
        geocodingService: GeocodingService = new GeocodingService()
    ) {
        this.eventRepository = eventRepository;
        this.weatherService = weatherService;
        this.geocodingService = geocodingService;
    }

    /**
     * Creates a new event for an organization with optional weather data
     *
     * If location data or address is provided with the event request, this method will
     * automatically fetch and attach weather forecast data from Open-Meteo.
     * Weather fetching failures will be logged but won't prevent event creation.
     *
     * @param orgID - The organization ID that owns the event
     * @param eventRequest - Event details including title, description, date and optional location or address
     * @returns The created Event object with weather data if available
     * @throws AppError for validation failures or database errors
     */
    async addEventToOrganization(orgID: string, eventRequest: EventRequest): Promise<Event> {
        try {
            if (!orgID) throw new AppError('Invalid organization ID.', 400);

            // Validate event request
            if (
                !eventRequest ||
                !eventRequest.title ||
                !eventRequest.description ||
                !eventRequest.date
            ) {
                throw new AppError('Missing required fields: title, description, or date.', 400);
            }

            // If address is provided but no location, geocode the address
            if (eventRequest.address && !eventRequest.location) {
                try {
                    const geocodingResult = await this.geocodingService.geocodeAddress(
                        eventRequest.address
                    );
                    // Add the geocoded location to the event request
                    eventRequest.location = {
                        latitude: geocodingResult.latitude,
                        longitude: geocodingResult.longitude,
                        name: geocodingResult.displayName,
                    };
                    logger.info(
                        `Geocoded address "${eventRequest.address}" to coordinates [${geocodingResult.latitude}, ${geocodingResult.longitude}]`
                    );
                } catch (geocodingError) {
                    // Log the error but continue without location data
                    logger.error('Error geocoding address:', geocodingError);
                    // Don't throw - we'll create the event without location data
                }
            }

            // Create event object
            const event: Event = createEvent(orgID, eventRequest);

            // Save to database
            const createdEvent = await this.eventRepository.createOrgEvent(event);

            // If location is provided, fetch and add weather data
            if (
                createdEvent.location &&
                typeof createdEvent.location.latitude === 'number' &&
                typeof createdEvent.location.longitude === 'number'
            ) {
                try {
                    const weatherData = await this.weatherService.getWeatherForLocation(
                        createdEvent.location.latitude,
                        createdEvent.location.longitude,
                        createdEvent.date
                    );

                    // Update the event with weather data
                    return await this.eventRepository.updateEventWeather(
                        createdEvent.id,
                        weatherData
                    );
                } catch (weatherError) {
                    // Log the error but continue without weather data
                    logger.error('Error fetching weather data:', weatherError);
                    return createdEvent;
                }
            }

            return createdEvent;
        } catch (error: any) {
            throw new AppError(`Failed to create event: ${error.message}`, 500);
        }
    }

    /**
     * Adds a user to an event by creating an attendance record.
     *
     * @param userID - The ID of the user attending the event.
     * @param eventID - The ID of the event the user is attending.
     * @returns The created EventUser record.
     * @throws {AppError} If the database operation fails.
     */
    async addEventUser(userID: string, eventID: string): Promise<EventUser> {
        try {
            const eventUser: EventUser = createEventUser(userID, eventID);
            return await this.eventRepository.addAttendingEventRecord(eventUser);
        } catch (error: any) {
            throw new AppError(`Failed to create event: ${error.message}`, 500);
        }
    }

    /**
     * Removes a user from an event by removing an attendance record.
     *
     * @param userID - The ID of the user attending the event.
     * @param eventID - The ID of the event the user is attending.
     * @returns The deleted EventUser record.
     * @throws {AppError} If the database operation fails.
     */
    async removeEventUser(userID: string, eventID: string): Promise<Boolean> {
        try {
            return await this.eventRepository.removeAttendingEventRecord(userID, eventID);
        } catch (error: any) {
            throw new AppError(`Failed to create event: ${error.message}`, 500);
        }
    }

    /**
     * Refreshes the weather forecast data for an existing event
     *
     * This method fetches the latest weather data from Open-Meteo based on
     * the event's stored location information and date. Useful for updating
     * forecasts as the event date approaches.
     *
     * @param eventId - The ID of the event to refresh weather data for
     * @returns The updated event with fresh weather data
     * @throws AppError if event not found, missing location data, or API errors
     */
    async refreshEventWeather(eventId: string): Promise<Event> {
        try {
            const event = await this.findEventById(eventId);

            if (!event) {
                throw new AppError('Event not found', 404);
            }

            if (
                !event.location ||
                typeof event.location.latitude !== 'number' ||
                typeof event.location.longitude !== 'number'
            ) {
                throw new AppError('Event does not have location data', 400);
            }

            const weatherData = await this.weatherService.getWeatherForLocation(
                event.location.latitude,
                event.location.longitude,
                event.date
            );

            return await this.eventRepository.updateEventWeather(eventId, weatherData);
        } catch (error: any) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(`Failed to refresh event weather: ${error.message}`, 500);
        }
    }

    /**
     * Retrieves all events for a given organization
     *
     * @param orgID - The organization ID to fetch events for
     * @returns A list of events for the organization
     * @throws AppError for invalid input or database errors
     */
    async getAllOrganizationEvents(orgID: string): Promise<Event[]> {
        try {
            if (!orgID) throw new AppError('Invalid organization ID.', 400);

            return await this.eventRepository.getOrgEvents(orgID);
        } catch (error: any) {
            throw new AppError(`Failed to retrieve organization events: ${error.message}`, 500);
        }
    }

    /**
     * Retrieves all public events for a given organization with pagination support
     *
     * @param orgID - The organization ID to fetch public events for
     * @returns Object containing events array and pagination key
     * @throws AppError for invalid input or database errors
     */
    async getAllPublicOrganizationEvents(
        orgID: string
    ): Promise<{ events: Event[]; newLastEvaluatedKey: Record<string, any> | null }> {
        try {
            if (!orgID) throw new AppError('Invalid organization ID.', 400);

            return await this.eventRepository.getPublicOrgEvents(orgID);
        } catch (error: any) {
            throw new AppError(`Failed to retrieve organization events: ${error.message}`, 500);
        }
    }

    /**
     * Finds an event-user relationship by event ID and user ID
     *
     * @param eventId - The event ID to check
     * @param userId - The user ID to check
     * @returns The event-user relationship if found
     * @throws AppError if relationship not found or database errors
     */
    async findEventUserbyUser(eventId: string, userId: string): Promise<EventUser | null> {
        try {
            const eventUser = await this.eventRepository.findEventUserbyUser(eventId, userId);

            if (!eventUser) {
                throw new AppError(`No Event-User found!`, 400);
            }

            return eventUser;
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(
                `Finding Event-User by User failed! ${(error as Error).message}`,
                500
            );
        }
    }

    /**
     * Finds an event by its ID
     *
     * @param eventId - The ID of the event to find
     * @returns The event if found
     * @throws AppError if event not found or database errors
     */
    async findEventById(eventId: string): Promise<Event | null> {
        try {
            const event = await this.eventRepository.findEventById(eventId);

            if (!event) {
                throw new AppError(`No Event found!`, 400);
            }

            return event as Event;
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(`Finding Event by ID failed! ${(error as Error).message}`, 500);
        }
    }

    /**
     * Toggles an event's public/private status
     *
     * @param event - The event to update publicity for
     * @returns The updated event
     * @throws AppError if event not found or update fails
     */
    async updateEventPublicity(event: Event): Promise<Event | null> {
        try {
            const existingEvent = await this.findEventById(event.id);

            if (!existingEvent) {
                throw new AppError(`No Event found!`, 400);
            }

            existingEvent.isPublic = !existingEvent.isPublic;

            const updatedEvent = await this.eventRepository.updateEventPublicity(existingEvent);

            if (updatedEvent === null) {
                throw new AppError(`Updating Event's publicity failed!`, 500);
            }
            return updatedEvent as Event;
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(
                `Updating Event's publicity failed! ${(error as Error).message}`,
                500
            );
        }
    }

    /**
     * Updates an entire event object in the database
     *
     * @param event - The event object with updated fields
     * @returns The updated event
     * @throws AppError if database operation fails
     */
    async updateEvent(event: Event): Promise<Event> {
        try {
            return await this.eventRepository.updateEvent(event);
        } catch (error: any) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(`Failed to update event: ${error.message}`, 500);
        }
    }

    /**
     * Updates just the weather data for an event
     *
     * @param eventId - The ID of the event to update weather for
     * @param weatherData - The weather data to store with the event
     * @returns The updated event with weather data
     * @throws AppError if database operation fails
     */
    async updateEventWeather(eventId: string, weatherData: WeatherData): Promise<Event> {
        try {
            return await this.eventRepository.updateEventWeather(eventId, weatherData);
        } catch (error: any) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(`Failed to update event weather: ${error.message}`, 500);
        }
    }

    /**
     * Gets all the events that a user is attending.
     *
     * @param userID - The ID of the user for which you are grabing all events
     * @returns all the events for the user
     * @throws AppError if database operation fails
     */
    async getAllUserEvents(userId: string): Promise<Event[]> {
        try {
            return await this.eventRepository.getUserEvents(userId);
        }
        catch (error: any) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(`Failed to update event weather: ${error.message}`, 500);
        }
    }

    /**
  * Deletes an event and all associated resources (attendance records, photos, and tags)
  * @param orgName The organization name
  * @param eventId The ID of the event to delete
  * @param adminId The ID of the admin requesting deletion
  * @returns True if the deletion was successful
  * @throws AppError if any step of the deletion process fails
  */
    async deleteEvent(orgName: string, eventId: string, adminId: string): Promise<boolean> {
        try {
            // Verify the event exists and belongs to the organization
            const event = await this.findEventById(eventId);

            if (!event) {
                throw new AppError('Event not found', 404);
            }

            // Check that the event belongs to the organization
            const organizationId = event.GSI2PK;
            const expectedOrgId = `ORG#${orgName.toUpperCase()}`;

            if (organizationId !== expectedOrgId) {
                throw new AppError('Event does not belong to this organization', 403);
            }

            // 1. Get all photos for the event (we need this before deleting the event)
            const photoRepository = new PhotoRepository();
            const s3Service = new S3Service();
            const tagRepository = new TagRepository();
            const photos = await photoRepository.getPhotosByEvent(eventId);

            // 2. Delete all attendance records for the event
            await this.eventRepository.deleteAllEventAttendance(eventId);

            // 3. Delete all photos from S3 and the database, including their tags
            for (const photo of photos) {
                try {
                    // Get the S3 key from metadata or extract it from the URL
                    const s3Key = photo.metadata?.s3Key ||
                        (() => {
                            try {
                                // Parse the URL and extract the path
                                const urlParts = new URL(photo.url);
                                // For pre-signed URLs, we need to carefully extract just the path
                                // without query parameters
                                return urlParts.pathname.substring(1); // Remove leading slash
                            } catch (error) {
                                logger.error(`Error parsing photo URL for photo ${photo.id}: ${photo.url}`, error);
                                return null;
                            }
                        })();

                    // 3.1 Delete tags for this photo
                    try {
                        // Get all tags for this photo
                        const photoTags = await tagRepository.getTagsByPhoto(photo.id);

                        // Delete each tag
                        for (const tag of photoTags) {
                            try {
                                await tagRepository.deleteTag(tag.userId);
                                logger.info(`Successfully deleted tag for user ${tag.userId} from photo ${photo.id}`);
                            } catch (tagError) {
                                logger.error(`Error deleting tag for user ${tag.userId} from photo ${photo.id}:`, tagError);
                                // Continue with other tags even if one fails
                            }
                        }
                    } catch (tagsError) {
                        logger.error(`Error retrieving or deleting tags for photo ${photo.id}:`, tagsError);
                        // Continue with photo deletion even if tags deletion fails
                    }

                    // 3.2 Delete the photo file from S3
                    if (s3Key) {
                        try {
                            await s3Service.deleteFile(s3Key);
                            logger.info(`Successfully deleted photo file from S3: ${s3Key}`);
                        } catch (s3Error) {
                            // Check the error type before accessing properties
                            const errorMessage = s3Error instanceof Error
                                ? s3Error.message
                                : 'Unknown error';
                            logger.error(`Error deleting photo file from S3 for photo ${photo.id}: ${errorMessage}`);
                            // Consider whether to retry or propagate the error
                        }
                    } else {
                        logger.warn(`No S3 key found for photo ${photo.id} - S3 file might not be deleted`);
                    }

                    // 3.3 Delete the photo record from the database
                    await photoRepository.deletePhoto(photo.id);
                    logger.info(`Successfully deleted photo record from database: ${photo.id}`);
                } catch (error) {
                    // Log the error but continue with other photos
                    logger.error(`Error deleting photo ${photo.id}:`, error);
                }
            }

            // 4. Finally, delete the event itself
            const result = await this.eventRepository.deleteEvent(eventId);

            return result;
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(`Failed to delete event: ${(error as Error).message}`, 500);
        }
    }
}}

src/services/geocodingService.ts:
{
import { AppError } from '../middleware/errorHandler';
import { logger } from '../util/logger';

/**
 * Response structure from Nominatim API
 */
interface NominatimResponse {
    place_id: number;
    lat: string;
    lon: string;
    display_name: string;
    address: {
        road?: string;
        city?: string;
        state?: string;
        postcode?: string;
        country?: string;
        [key: string]: string | undefined;
    };
}

/**
 * Response structure for geocoding results
 */
export interface GeocodingResult {
    latitude: number;
    longitude: number;
    displayName: string;
}

export class GeocodingService {
    private readonly baseUrl = 'https://nominatim.openstreetmap.org/search';
    private readonly userAgent = 'PhotoComp_App/1.0'; // Required by Nominatim terms of use

    /**
     * Converts an address string to latitude and longitude coordinates
     *
     * @param address The address to geocode
     * @returns Promise resolving to geocoding result with coordinates and display name
     * @throws AppError if geocoding fails or no results found
     */
    async geocodeAddress(address: string): Promise<GeocodingResult> {
        try {
            if (!address || address.trim() === '') {
                throw new AppError('Address is required', 400);
            }

            // Build URL with query parameters
            const url = new URL(this.baseUrl);
            url.searchParams.append('q', address);
            url.searchParams.append('format', 'json');
            url.searchParams.append('addressdetails', '1');
            url.searchParams.append('limit', '1');

            // Make the request to Nominatim API
            const response = await fetch(url.toString(), {
                headers: {
                    'User-Agent': this.userAgent,
                    'Accept-Language': 'en-US,en;q=0.9',
                },
            });

            if (!response.ok) {
                throw new AppError(`Geocoding service error: ${response.statusText}`, 500);
            }

            const data = (await response.json()) as NominatimResponse[];

            // Check if we got valid results
            if (!data || data.length === 0) {
                throw new AppError('No results found for the provided address', 404);
            }

            const result = data[0];

            // Parse latitude and longitude as floating point numbers
            const latitude = parseFloat(result.lat);
            const longitude = parseFloat(result.lon);

            if (isNaN(latitude) || isNaN(longitude)) {
                throw new AppError('Invalid coordinates received from geocoding service', 500);
            }

            logger.info(
                `Successfully geocoded address: "${address}" to lat=${latitude}, lon=${longitude}`
            );

            return {
                latitude,
                longitude,
                displayName: result.display_name,
            };
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }
            logger.error('Geocoding error:', error);
            throw new AppError(`Failed to geocode address: ${(error as Error).message}`, 500);
        }
    }
}
}

src/services/imageService.ts:
{
import sharp from 'sharp';
import { logger } from '../util/logger';
import { PhotoSizes } from '../models/Photo';

interface ImageInfo {
    format: string;
    width: number;
    height: number;
    size: number;
}

interface ResizeOptions {
    width?: number;
    height?: number;
    fit?: 'cover' | 'contain' | 'fill' | 'inside' | 'outside';
    quality?: number;
}

/**
 * Service for processing and resizing images
 * Uses the Sharp library to manipulate images efficiently
 * Implements smart resizing to avoid quality loss from upscaling
 */
export class ImageService {
    // Define standard sizes for different use cases
    static readonly SIZES = {
        THUMBNAIL: { width: 200, quality: 80 },
        MEDIUM: { width: 400, quality: 85 },
        LARGE: { width: 1600, quality: 90 },
    };

    /**
     * Get image information from a buffer
     * @param buffer The image buffer
     * @returns Promise with image metadata
     */
    async getImageInfo(buffer: Buffer): Promise<ImageInfo> {
        try {
            const metadata = await sharp(buffer).metadata();
            
            return {
                format: metadata.format || 'unknown',
                width: metadata.width || 0,
                height: metadata.height || 0,
                size: buffer.length,
            };
        } catch (error) {
            logger.error('Error getting image info:', error);
            throw new Error(`Failed to get image info: ${(error as Error).message}`);
        }
    }

    /**
     * Resize an image to different dimensions
     * Only downscales (never upscales) to prevent quality loss
     * @param buffer The original image buffer
     * @param options Resize options
     * @param originalWidth Original image width to prevent upscaling
     * @returns Promise with the resized image buffer
     */
    async resizeImage(
        buffer: Buffer, 
        options: ResizeOptions, 
        originalWidth: number
    ): Promise<Buffer> {
        try {
            const { width, height, fit = 'cover', quality = 85 } = options;
            
            // Get original image metadata
            const metadata = await sharp(buffer).metadata();
            const originalFormat = metadata.format;
            
            // Calculate target width - never upscale
            // If requested width is larger than original, use original width instead
            const targetWidth = width && width < originalWidth ? width : originalWidth;
            
            // Prepare the resize operation
            let resizer = sharp(buffer).resize({
                width: targetWidth,
                height, // Height will adapt based on aspect ratio if not specified
                fit
            });
            
            // Apply appropriate compression based on format
            if (originalFormat === 'jpeg' || originalFormat === 'jpg') {
                resizer = resizer.jpeg({ quality });
            } else if (originalFormat === 'png') {
                // For PNG files, we'll convert to JPEG if no transparency is detected
                // This can dramatically reduce file size for web display
                const { hasAlpha } = metadata;
                
                if (hasAlpha) {
                    // Keep as PNG with quality setting if it has transparency
                    resizer = resizer.png({ quality: Math.min(quality, 100) });
                } else {
                    // Convert to JPEG if no transparency - much smaller file size
                    resizer = resizer.jpeg({ quality });
                }
            } else if (originalFormat === 'webp') {
                resizer = resizer.webp({ quality });
            } else {
                // Default to jpeg for other formats
                resizer = resizer.jpeg({ quality });
            }
            
            return await resizer.toBuffer();
        } catch (error) {
            logger.error('Error resizing image:', error);
            throw new Error(`Failed to resize image: ${(error as Error).message}`);
        }
    }

    /**
     * Generate multiple sizes of an image, but only sizes smaller than the original
     * This prevents quality loss from upscaling
     * @param buffer The original image buffer
     * @param baseKey The base S3 key without extension
     * @param fileExtension The file extension
     * @returns Object with all processed image buffers and their S3 keys
     */
    async generateImageSizes(
        buffer: Buffer, 
        baseKey: string,
        fileExtension: string
    ): Promise<{
        buffers: Record<string, Buffer>;
        s3Keys: Record<string, string>;
        dimensions: Record<string, { width: number; height: number }>;
    }> {
        try {
            // Get original image info
            const imageInfo = await this.getImageInfo(buffer);
            const originalWidth = imageInfo.width;
            
            // Determine final file extension based on format
            let finalExtension = fileExtension;
            // If the original image format can be detected, use that for more accurate extension
            if (imageInfo.format && imageInfo.format !== 'unknown') {
                finalExtension = imageInfo.format;
            }
            
            // Initialize output containers
            const buffers: Record<string, Buffer> = {};
            const s3Keys: Record<string, string> = {};
            const dimensions: Record<string, { width: number; height: number }> = {};
            
            // Always include the original image
            buffers['original'] = buffer;
            s3Keys['original'] = `${baseKey}.${finalExtension}`;
            dimensions['original'] = { width: imageInfo.width, height: imageInfo.height };
            
            logger.info(`Original image dimensions: ${imageInfo.width}x${imageInfo.height}, ${imageInfo.size} bytes`);
            
            // Only create thumbnail if original is larger than thumbnail size
            if (originalWidth > ImageService.SIZES.THUMBNAIL.width) {
                const thumbnailBuffer = await this.resizeImage(
                    buffer, 
                    ImageService.SIZES.THUMBNAIL, 
                    originalWidth
                );
                const thumbnailInfo = await this.getImageInfo(thumbnailBuffer);
                
                buffers['thumbnail'] = thumbnailBuffer;
                s3Keys['thumbnail'] = `${baseKey}_thumbnail.${finalExtension}`;
                dimensions['thumbnail'] = { width: thumbnailInfo.width, height: thumbnailInfo.height };
                
                logger.info(`Thumbnail dimensions: ${thumbnailInfo.width}x${thumbnailInfo.height}, ${thumbnailInfo.size} bytes`);
            } else {
                logger.info(`Original image (${originalWidth}px) smaller than thumbnail size (${ImageService.SIZES.THUMBNAIL.width}px) - skipping thumbnail`);
            }
            
            // Only create medium size if original is larger than medium size
            if (originalWidth > ImageService.SIZES.MEDIUM.width) {
                const mediumBuffer = await this.resizeImage(
                    buffer, 
                    ImageService.SIZES.MEDIUM, 
                    originalWidth
                );
                const mediumInfo = await this.getImageInfo(mediumBuffer);
                
                buffers['medium'] = mediumBuffer;
                s3Keys['medium'] = `${baseKey}_medium.${finalExtension}`;
                dimensions['medium'] = { width: mediumInfo.width, height: mediumInfo.height };
                
                logger.info(`Medium dimensions: ${mediumInfo.width}x${mediumInfo.height}, ${mediumInfo.size} bytes`);
            } else {
                logger.info(`Original image (${originalWidth}px) smaller than medium size (${ImageService.SIZES.MEDIUM.width}px) - skipping medium`);
            }
            
            // Only create large size if original is larger than large size
            if (originalWidth > ImageService.SIZES.LARGE.width) {
                const largeBuffer = await this.resizeImage(
                    buffer, 
                    ImageService.SIZES.LARGE, 
                    originalWidth
                );
                const largeInfo = await this.getImageInfo(largeBuffer);
                
                buffers['large'] = largeBuffer;
                s3Keys['large'] = `${baseKey}_large.${finalExtension}`;
                dimensions['large'] = { width: largeInfo.width, height: largeInfo.height };
                
                logger.info(`Large dimensions: ${largeInfo.width}x${largeInfo.height}, ${largeInfo.size} bytes`);
            } else {
                logger.info(`Original image (${originalWidth}px) smaller than large size (${ImageService.SIZES.LARGE.width}px) - skipping large`);
            }
            
            return {
                buffers,
                s3Keys,
                dimensions
            };
        } catch (error) {
            logger.error('Error generating image sizes:', error);
            throw new Error(`Failed to generate image sizes: ${(error as Error).message}`);
        }
    }
}}

src/services/orgMembershipService.ts:
{
// src/services/orgMembershipService.ts

import { EventService } from './eventService';
import { OrgService } from './orgService';
import { UserService } from './userService';
import { OrgMembershipRepository } from '../repositories/orgMembershipRepository';
import {
    OrganizationMembershipRequest,
    UserOrganizationRelationship,
    createOrganizationMembershipRequest,
    addOrganizationAdmin,
} from '../models/Organizations';
import { User, UserRole } from '../models/User';
import { AppError } from '../middleware/errorHandler';

export class OrgMembershipService {
    private orgMembershipRepository: OrgMembershipRepository;
    private eventService: EventService;
    private orgService: OrgService;
    private userService: UserService;

    constructor(
        orgMembershipRepository: OrgMembershipRepository = new OrgMembershipRepository(),
        eventService: EventService = new EventService(),
        orgService: OrgService = new OrgService(),
        userService: UserService = new UserService()
    ) {
        this.orgMembershipRepository = orgMembershipRepository;
        this.eventService = eventService;
        this.orgService = orgService;
        this.userService = userService;
    }

    /**
     * Submits a request to join an organization
     * @param organizationName The name of the organization to join
     * @param userId The ID of the user requesting to join
     * @param message Optional message from the user
     * @returns The created membership request
     */
    async applyToOrganization(
        organizationName: string,
        userId: string,
        message?: string
    ): Promise<OrganizationMembershipRequest> {
        const organization = await this.orgService.findOrgByName(organizationName);
        if (!organization) {
            throw new AppError('Organization not found', 404);
        }

        const member = await this.orgService.isMemberOfOrg(organizationName, userId);
        if (member) {
            throw new AppError('You are already a part of this organization', 400);
        }

        const events = await this.eventService.getAllOrganizationEvents(organizationName);
        if (!events || events.length === 0) {
            throw new AppError('Cannot apply to an organization without any events', 400);
        }

        const request = createOrganizationMembershipRequest(organizationName, userId, message);

        return await this.orgMembershipRepository.createMembershipRequest(request);
    }

    /**
     * Get all pending membership requests for an organization
     * @param organizationName The name of the organization
     * @returns List of pending membership requests
     */
    async getPendingRequests(organizationName: string): Promise<OrganizationMembershipRequest[]> {
        return await this.orgMembershipRepository.getPendingRequestsByOrganization(
            organizationName
        );
    }

    /**
     * Approve a membership request
     * @param organizationName The name of the organization
     * @param userId The ID of the user whose request is being approved
     * @returns The new user-org relationship
     */
    async approveRequest(
        organizationName: string,
        userId: string
    ): Promise<UserOrganizationRelationship | null> {
        const events = await this.eventService.getAllOrganizationEvents(organizationName);
        if (!events || events.length === 0) {
            throw new AppError(
                'Cannot approve new members for an organization without events',
                400
            );
        }

        // Check if request exists
        // We don't need to check the status since we're going to delete it regardless
        const requests = await this.getPendingRequests(organizationName);
        const userRequest = requests.find(req => req.userId === userId);

        if (!userRequest) {
            throw new AppError('Membership request not found', 404);
        }

        const user: User = (await this.userService.getUserById(userId)) as User;

        const userOrgRelationship = {
            ...addOrganizationAdmin(organizationName, userId, user.email),
            role: UserRole.MEMBER,
        };

        const membership =
            await this.orgService.createUserOrganizationRelationship(userOrgRelationship);

        await this.orgMembershipRepository.deleteMembershipRequest(organizationName, userId);

        return membership;
    }

    /**
     * Deny a membership request
     * @param organizationName The name of the organization
     * @param userId The ID of the user whose request is being denied
     * @returns Boolean indicating success
     */
    async denyRequest(organizationName: string, userId: string): Promise<boolean> {
        const requests = await this.getPendingRequests(organizationName);
        const userRequest = requests.find(req => req.userId === userId);

        if (!userRequest) {
            throw new AppError('Membership request not found', 404);
        }

        return await this.orgMembershipRepository.deleteMembershipRequest(organizationName, userId);
    }
}
}

src/services/orgService.ts:
{
import { OrgRepository } from '../repositories/orgRepository';
import { S3Service } from '../services/s3Service';
import {
    Organization,
    OrganizationCreateRequest,
    createOrganization,
    OrganizationUpdateRequest,
    updateOrganization,
    UserOrganizationRelationship,
    addOrganizationAdmin,
} from '../models/Organizations';
import { AppError } from '../middleware/errorHandler';
import { UserRole } from '../models/User';

export class OrgService {
    private orgRepository: OrgRepository;
    private s3Service: S3Service;

    constructor(
        orgRepository: OrgRepository = new OrgRepository(),
        s3Service: S3Service = new S3Service()
    ) {
        this.orgRepository = orgRepository;
        this.s3Service = s3Service;
    }

    async validateUrl(url: string | undefined): Promise<void> {
        if (url !== undefined && url.length !== 0) {
            try {
                new URL(url);
            } catch (error) {
                throw new AppError(`Invalid URL`, 400);
            }
        }
    }

    validateUserOrgAdmin(userOrg: UserOrganizationRelationship): boolean {
        if (userOrg.role !== `ADMIN`) {
            return false;
        }
        return true;
    }

    validateUserOrgMember(userOrg: UserOrganizationRelationship): boolean {
        return userOrg?.role != null;
    }

    async createOrg(
        createOrg: OrganizationCreateRequest,
        userId: string
    ): Promise<OrganizationCreateRequest | null> {
        try {
            await this.validateUrl(createOrg.logoUrl);

            // Change this condition to check only for name
            if (!createOrg.name) {
                throw new AppError('Organization name is required', 400);
            }

            const existingOrg = await this.findOrgByName(createOrg.name);

            if (existingOrg) {
                throw new AppError(`Organization name already in use!`, 409);
            }

            // Upload logo to S3 and get the S3 key
            const logoS3Key = await this.s3Service.uploadLogoFromUrl(
                createOrg.logoUrl,
                createOrg.name
            );

            // Get pre-signed URL for the logo
            const preSignedUrl = await this.s3Service.getLogoPreSignedUrl(logoS3Key);

            // Update the organization data with S3 key and pre-signed URL
            const organizationData = {
                ...createOrg,
                logoS3Key: logoS3Key,
                // Store the pre-signed URL in logoUrl (or consider updating your model to have both)
                logoUrl: preSignedUrl,
            };

            // Create the organization with the updated data
            const org = createOrganization(organizationData, userId);

            try {
                const createdOrg = await this.orgRepository.createOrg(org);
                return organizationData;
            } catch (error) {
                if (error instanceof AppError) {
                    throw error;
                }
                throw new AppError(
                    `Organization creation failed: DB! ${(error as Error).message}`,
                    500
                );
            }
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(
                `Organization creation failed: Model! ${(error as Error).message}`,
                500
            );
        }
    }

    async createUserAdmin(
        orgName: string,
        userId: string,
        email: string
    ): Promise<UserOrganizationRelationship | null> {
        const userAdmin = addOrganizationAdmin(orgName, userId, email);

        try {
            const createUserAdmin = await this.orgRepository.createUserAdmin(userAdmin);

            return createUserAdmin;
        } catch (error: any) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(
                `User Organization creation failed: Model! ${(error as Error).message}`,
                500
            );
        }
    }

    async findOrgByName(name: string): Promise<Organization | null> {
        try {
            return await this.orgRepository.findOrgByName(name);
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(
                `Finding Organization by ID failed! ${(error as Error).message}`,
                500
            );
        }
    }

    async findSpecificOrgByUser(
        name: string,
        userId: string
    ): Promise<UserOrganizationRelationship | null> {
        try {
            const userOrg = await this.orgRepository.findSpecificOrgByUser(name, userId);
            if (!userOrg) {
                throw new AppError(`You are NOT part of this Organization`, 401);
            }

            return userOrg;
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(
                `Finding User Organization failed! ${(error as Error).message}`,
                500
            );
        }
    }

    async findOrgsByUser(userId: string): Promise<Organization[] | null> {
        try {
            const results = await this.orgRepository.findOrgsByUser(userId);

            if (!results) {
                throw new AppError(`No Organizations found!`, 400);
            }

            // Generate fresh pre-signed URLs for all organization logos
            for (const org of results) {
                if (org.logoS3Key) {
                    try {
                        org.logoUrl = await this.s3Service.getLogoPreSignedUrl(org.logoS3Key);
                    } catch (error) {
                        // Log the error but continue processing other organizations
                        console.error(`Error getting pre-signed URL for ${org.name}:`, error);
                    }
                }
            }

            return results;
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(
                `Finding Organization by User failed! ${(error as Error).message}`,
                500
            );
        }
    }

    async updateOrgByName(
        org: OrganizationUpdateRequest
    ): Promise<OrganizationUpdateRequest | null> {
        try {
            if (!org.name) {
                throw new AppError(`You need to specify the Organization name.`, 400);
            }

            await this.validateUrl(org.logoUrl);
            await this.validateUrl(org.website);

            const existingOrg = await this.orgRepository.findOrgByName(org.name);

            if (!existingOrg) {
                throw new AppError(`No Organizations found!`, 400);
            }

            const updatedOrg = updateOrganization(org, existingOrg);

            return await this.orgRepository.updateOrgByName(updatedOrg);
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(`Updating Organization failed! ${(error as Error).message}`, 500);
        }
    }

    async findAllPublicOrgs(
        lastEvaluatedKey?: Record<string, any>
    ): Promise<{ orgs: Organization[]; newLastEvaluatedKey: Record<string, any> | null }> {
        try {
            return await this.orgRepository.findAllPublicOrgs(lastEvaluatedKey);
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(`Updating Organization failed! ${(error as Error).message}`, 500);
        }
    }

    /**
     * Creates a user-organization relationship
     * @param userOrg The user-organization relationship to create
     * @returns The created relationship
     */
    async createUserOrganizationRelationship(
        userOrg: UserOrganizationRelationship
    ): Promise<UserOrganizationRelationship | null> {
        try {
            return await this.orgRepository.createUserAdmin(userOrg);
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(
                `Failed to create user-organization relationship: ${(error as Error).message}`,
                500
            );
        }
    }

    /**
     * Get all members of an organization
     * @param orgName The name of the organization
     * @returns Array of user-organization relationships
     */
    async getOrgMembers(orgName: string): Promise<UserOrganizationRelationship[]> {
        try {
            const members = await this.orgRepository.getOrgMembers(orgName);

            if (!members || members.length === 0) {
                throw new AppError('No members found for this organization', 404);
            }

            return members;
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(
                `Failed to get organization members: ${(error as Error).message}`,
                500
            );
        }
    }

    /**
     * Remove a member from an organization
     * @param orgName The name of the organization
     * @param userId The ID of the user to remove
     * @returns True if successful
     */
    async removeMember(orgName: string, userId: string): Promise<boolean> {
        try {
            // Check if the member exists in the organization
            const member = await this.orgRepository.findSpecificOrgByUser(orgName, userId);

            if (!member) {
                throw new AppError('Member not found in this organization', 404);
            }

            // Remove the member
            const result = await this.orgRepository.removeMember(orgName, userId);

            if (!result) {
                throw new AppError('Failed to remove member', 500);
            }

            return result;
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(`Failed to remove member: ${(error as Error).message}`, 500);
        }
    }

    /**
     * Remove yourself from an organization
     * @param orgName The name of the organization
     * @param userId your userId
     * @returns True if successful
     */
    async leaveOrganization(orgName: string, userId: string): Promise<boolean> {
        try {
            const member = await this.orgRepository.findSpecificOrgByUser(orgName, userId);

            if (!member) {
                throw new AppError('Member not found in this organization', 404);
            }

            if (member.userId != userId) {
                throw new AppError('You cannot make another member leave', 403);
            }

            if (member.role === UserRole.ADMIN) {
                const orgMembers = await this.orgRepository.getOrgMembers(orgName);
                const adminCount = orgMembers.filter(
                    member => member.role === UserRole.ADMIN
                ).length;

                if (adminCount <= 1) {
                    throw new AppError(
                        'Cannot leave organization: You are the only admin. Please assign another admin first.',
                        400
                    );
                }
            }

            return await this.orgRepository.removeMember(orgName, userId);
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(`Failed to leave organization: ${(error as Error).message}`, 500);
        }
    }

    /**
     * Update a member's role in an organization
     * @param orgName The name of the organization
     * @param userId The ID of the user to update
     * @param role The new role for the user
     * @returns The updated user-organization relationship
     */
    async updateMemberRole(
        orgName: string,
        userId: string,
        role: UserRole
    ): Promise<UserOrganizationRelationship> {
        try {
            // Check if the member exists in the organization
            const member = await this.orgRepository.findSpecificOrgByUser(orgName, userId);

            if (!member) {
                throw new AppError('Member not found in this organization', 404);
            }

            // Update the member's role
            const updatedMember = await this.orgRepository.updateMemberRole(orgName, userId, role);

            if (!updatedMember) {
                throw new AppError('Failed to update member role', 500);
            }

            return updatedMember;
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(`Failed to update member role: ${(error as Error).message}`, 500);
        }
    }

    /**
     * Check if a user is already a member of the organization
     * @param orgName The name of the organization
     * @param userId The ID of the user to check
     * @returns true if the user is already a member of the org
     */
    async isMemberOfOrg(orgName: string, userId: string): Promise<Boolean> {
        try {
            return (await this.orgRepository.findSpecificOrgByUser(orgName, userId)) != null;
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(
                `Failed to check if user is member of org: ${(error as Error).message}`,
                500
            );
        }
    }

    /**
 * Creates an organization with a logo uploaded as a file
 * @param createOrgRequest The organization data
 * @param userId The ID of the user creating the organization
 * @param logoFile The logo file buffer
 * @param mimeType The mimetype of the file
 * @returns The created organization
 */
    async createOrgWithFileUpload(
        createOrgRequest: Omit<OrganizationCreateRequest, 'logoUrl'>,
        userId: string,
        logoFile: Buffer,
        mimeType: string
    ): Promise<OrganizationCreateRequest | null> {
        try {
            // Check only for name
            if (!createOrgRequest.name) {
                throw new AppError('Organization name is required', 400);
            }

            const existingOrg = await this.findOrgByName(createOrgRequest.name);

            if (existingOrg) {
                throw new AppError(`Organization name already in use!`, 409);
            }

            // Upload logo to S3 using buffer
            const logoS3Key = await this.s3Service.uploadLogoFromBuffer(
                logoFile,
                createOrgRequest.name,
                mimeType
            );

            // Get pre-signed URL for the logo
            const preSignedUrl = await this.s3Service.getLogoPreSignedUrl(logoS3Key);

            // Create the complete organization data with S3 key and pre-signed URL
            const organizationData = {
                ...createOrgRequest,
                logoUrl: preSignedUrl,
                logoS3Key: logoS3Key,
            };

            // Create the organization with the updated data
            const org = createOrganization(organizationData, userId);

            try {
                const createdOrg = await this.orgRepository.createOrg(org);
                return organizationData;
            } catch (error) {
                if (error instanceof AppError) {
                    throw error;
                }
                throw new AppError(
                    `Organization creation failed: DB! ${(error as Error).message}`,
                    500
                );
            }
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(
                `Organization creation failed: Model! ${(error as Error).message}`,
                500
            );
        }
    }

    /**
 * Updates an organization's logo with a file upload
 * @param orgName The name of the organization
 * @param logoFile The logo file buffer
 * @param mimeType The mimetype of the file
 * @returns The updated S3 key and pre-signed URL
 */
    async updateOrgLogoWithFile(
        orgName: string,
        logoFile: Buffer,
        mimeType: string
    ): Promise<{ logoUrl: string; logoS3Key: string }> {
        try {
            // Find the existing organization
            const existingOrg = await this.findOrgByName(orgName);

            if (!existingOrg) {
                throw new AppError(`Organization not found`, 404);
            }

            // Upload the new logo
            const logoS3Key = await this.s3Service.uploadLogoFromBuffer(
                logoFile,
                orgName,
                mimeType
            );

            // Get pre-signed URL for the logo
            const preSignedUrl = await this.s3Service.getLogoPreSignedUrl(logoS3Key);

            return {
                logoUrl: preSignedUrl,
                logoS3Key: logoS3Key
            };
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(
                `Failed to update organization logo: ${(error as Error).message}`,
                500
            );
        }
    }
}
}

src/services/photoService.ts:
{
import { v4 as uuidv4 } from 'uuid';
import { PhotoRepository } from '../repositories/photoRepository';
import { S3Service } from './s3Service';
import { Photo, createPhoto, PhotoSizes } from '../models/Photo';
import { AppError } from '../middleware/errorHandler';
import { EventService } from './eventService';
import { logger } from '../util/logger';
import { EventRepository } from '../repositories/eventRepository';
import { Event as EventModel } from '../models/Event';
import { OrgService } from './orgService';
import { ImageService } from './imageService';

export class PhotoService {
    private photoRepository: PhotoRepository;
    private s3Service: S3Service;
    private eventService: EventService;
    private eventRepository: EventRepository;
    private imageService: ImageService;

    constructor(
        photoRepository: PhotoRepository = new PhotoRepository(),
        s3Service: S3Service = new S3Service(),
        eventService: EventService = new EventService(),
        eventRepository: EventRepository = new EventRepository(),
        imageService: ImageService = new ImageService()
    ) {
        this.photoRepository = photoRepository;
        this.s3Service = s3Service;
        this.eventService = eventService;
        this.eventRepository = eventRepository;
        this.imageService = imageService;
    }

     /**
     * Upload a photo for an event
     * Enhanced to handle either a single file or multiple files within the same request
     * 
     * @param photoId The unique ID for the photo (or null if batch upload)
     * @param eventId The event ID the photo belongs to
     * @param fileBuffer The file buffer containing the photo data
     * @param mimeType The MIME type of the photo
     * @param uploadedBy The user ID of who uploaded the photo
     * @param metadata Additional metadata for the photo
     * @returns The created photo object or array of photo objects
     */
     async uploadPhoto(
        photoId: string | null,
        eventId: string,
        fileBuffer: Buffer | Buffer[],
        mimeType: string | string[],
        uploadedBy: string,
        metadata?: {
            title?: string;
            description?: string;
            size?: number;
            mimeType?: string;
            s3Key?: string;
        }
    ): Promise<Photo | Photo[]> {
        try {
            // Verify that the event exists
            const event = await this.eventService.findEventById(eventId);
            if (!event) {
                throw new AppError(`Event not found: ${eventId}`, 404);
            }

            // Check if we're handling a single file or multiple files
            if (!Array.isArray(fileBuffer)) {
                // Single file upload - use existing logic
                const id = photoId || uuidv4();
                const singleMimeType = Array.isArray(mimeType) ? mimeType[0] : mimeType;
                return await this.processSinglePhoto(id, eventId, fileBuffer, singleMimeType, uploadedBy, metadata);
            } else {
                // Multiple file upload - process each file
                const photoPromises: Promise<Photo>[] = [];
                
                for (let i = 0; i < fileBuffer.length; i++) {
                    const id = uuidv4(); // Generate a new ID for each photo
                    const buffer = fileBuffer[i];
                    const mime = Array.isArray(mimeType) ? mimeType[i] : mimeType;
                    
                    // Use the same metadata for all photos in the batch
                    photoPromises.push(this.processSinglePhoto(id, eventId, buffer, mime, uploadedBy, metadata));
                }
                
                return await Promise.all(photoPromises);
            }
        } catch (error) {
            logger.error('Error uploading photo:', error);
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(`Failed to upload photo: ${(error as Error).message}`, 500);
        }
    }
    
    /**
     * Process a single photo upload
     * Helper method to keep code DRY
     */
    private async processSinglePhoto(
        id: string,
        eventId: string,
        buffer: Buffer,
        mimeType: string,
        uploadedBy: string,
        metadata?: {
            title?: string;
            description?: string;
            size?: number;
            mimeType?: string;
            s3Key?: string;
        }
    ): Promise<Photo> {
        // Create the base S3 key using a structured pattern
        const fileExtension = mimeType.split('/')[1] || 'jpg';
        const baseS3Key = `photos/${eventId}/${id}`;

        // Get original image info
        const imageInfo = await this.imageService.getImageInfo(buffer);

        // Generate different sizes of the image
        const {
            buffers,
            s3Keys,
            dimensions
        } = await this.imageService.generateImageSizes(buffer, baseS3Key, fileExtension);

        // Upload all sizes to S3
        await this.s3Service.uploadResizedImages(buffers, s3Keys, mimeType);

        // Generate pre-signed URLs for all sizes
        const urls = await this.s3Service.getMultiplePreSignedUrls(s3Keys);

        // Add S3 keys and dimensions to metadata
        const updatedMetadata = {
            ...(metadata || {}),
            width: imageInfo.width,
            height: imageInfo.height,
            size: imageInfo.size,
            mimeType: mimeType,
            s3Key: s3Keys.original, // Keep original s3Key for backward compatibility
            s3Keys: s3Keys // Store all S3 keys
        };

        // Create and save the photo record
        const photo = createPhoto(
            id, 
            eventId, 
            urls.original, // Keep original URL for backward compatibility
            uploadedBy,
            urls, // Add URLs for all sizes
            updatedMetadata
        );

        await this.photoRepository.createPhoto(photo);
        return photo;
    }

    /**
     * Get all photos for an event
     * @param eventId The event ID to get photos for
     * @returns Array of photos for the event
     */
    async getEventPhotos(eventId: string): Promise<Photo[]> {
        try {
            // Verify that the event exists
            const event = await this.eventService.findEventById(eventId);
            if (!event) {
                throw new AppError(`Event not found: ${eventId}`, 404);
            }

            // Get all photos for the event with better error handling
            try {
                const photos = await this.photoRepository.getPhotosByEvent(eventId);

                // Ensure photos is an array
                if (!Array.isArray(photos)) {
                    logger.warn(`Expected photos to be an array, but got: ${typeof photos}`);
                    return [];
                }

                // Refresh pre-signed URLs for all photos
                for (const photo of photos) {
                    try {
                        // Check if the photo has the new urls structure
                        if (photo.metadata?.s3Keys) {
                            // Generate fresh pre-signed URLs for all sizes
                            photo.urls = await this.s3Service.getMultiplePreSignedUrls(photo.metadata.s3Keys);
                            // Update the main URL to be the original for backward compatibility
                            photo.url = photo.urls.original;
                        } else if (photo?.metadata?.s3Key) {
                            // Legacy photo - just update the main URL
                            photo.url = await this.s3Service.getLogoPreSignedUrl(photo.metadata.s3Key);
                        } else if (photo?.url) {
                            // Very old format - try to extract the key from the URL
                            try {
                                const urlParts = new URL(photo.url);
                                const s3Key = urlParts.pathname.substring(1); // Remove leading slash
                                photo.url = await this.s3Service.getLogoPreSignedUrl(s3Key);
                            } catch (error) {
                                logger.error(`Error refreshing pre-signed URL for photo: ${error}`);
                                // Keep original URL if parsing fails
                            }
                        }
                    } catch (error) {
                        logger.error(`Error refreshing pre-signed URL: ${error}`);
                        // Continue processing other photos even if one fails
                    }
                }

                return photos;
            } catch (error) {
                logger.error(`Error in photoRepository.getPhotosByEvent: ${error}`);
                // Return empty array on repository error to prevent controller failure
                return [];
            }
        } catch (error) {
            logger.error('Error getting event photos:', error);
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(`Failed to get event photos: ${(error as Error).message}`, 500);
        }
    }

    /**
     * Delete a photo and all its sizes
     * @param photoId The ID of the photo to delete
     * @param eventId The event ID the photo belongs to (for validation)
     */
    async deletePhoto(photoId: string, eventId: string): Promise<void> {
        try {
            // Get the photo to verify it exists and belongs to the right event
            const photo = await this.photoRepository.getPhotoById(photoId);

            if (!photo) {
                throw new AppError(`Photo not found: ${photoId}`, 404);
            }

            if (photo.eventId !== eventId) {
                throw new AppError('Photo does not belong to the specified event', 400);
            }

            // Collect all S3 keys that need to be deleted
            const s3KeysToDelete: string[] = [];

            // Add all sizes from the new format if available
            if (photo.metadata?.s3Keys) {
                Object.values(photo.metadata.s3Keys).forEach(key => {
                    if (key) s3KeysToDelete.push(key);
                });
            } 
            // Add the legacy S3 key if available
            else if (photo.metadata?.s3Key) {
                s3KeysToDelete.push(photo.metadata.s3Key);
            }
            // Try to extract the key from the URL as a last resort
            else if (photo.url) {
                try {
                    const urlParts = new URL(photo.url);
                    const s3Key = urlParts.pathname.substring(1); // Remove leading slash
                    if (s3Key) s3KeysToDelete.push(s3Key);
                } catch (error) {
                    logger.error(`Error parsing photo URL: ${photo.url}`, error);
                }
            }

            // Delete the photo from the database first
            await this.photoRepository.deletePhoto(photoId);

            // Delete all the files from S3
            if (s3KeysToDelete.length > 0) {
                try {
                    await this.s3Service.deleteMultipleFiles(s3KeysToDelete);
                    logger.info(`Deleted photo files from S3: ${s3KeysToDelete.join(', ')}`);
                } catch (error) {
                    logger.error(`Error deleting photo files from S3: ${error}`);
                    // Continue even if S3 deletion fails, as the database record is already deleted
                }
            } else {
                logger.warn(`Could not determine S3 keys for photo: ${photoId}`);
            }
        } catch (error) {
            logger.error('Error deleting photo:', error);
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(`Failed to delete photo: ${(error as Error).message}`, 500);
        }
    }

    /**
     * Validates if a user has access to an event's photos
     * @param eventId The event ID to check access for
     * @param userId The user ID requesting access
     * @returns Boolean indicating if the user has access
     */
    async validateUserEventAccess(eventId: string, userId: string): Promise<boolean> {
        try {
            // Check if the user is attending the event
            const eventUser = await this.eventRepository.findEventUserbyUser(eventId, userId);
            return !!eventUser; // Return true if the user is found, false otherwise
        } catch (error) {
            logger.error('Error validating user event access:', error);
            return false; // Default to no access on error
        }
    }

    /**
     * Gets a download URL for a specific photo
     * @param photoId The ID of the photo to download
     * @param eventId The event ID the photo belongs to (for validation)
     * @param size The size of the photo to download (default: 'original')
     * @returns A pre-signed download URL for the photo
     */
    async getPhotoDownloadUrl(
        photoId: string, 
        eventId: string, 
        size: 'original' | 'thumbnail' | 'medium' | 'large' = 'original'
    ): Promise<string> {
        try {
            // Get the photo to verify it exists and belongs to the right event
            const photo = await this.photoRepository.getPhotoById(photoId);

            if (!photo) {
                throw new AppError(`Photo not found: ${photoId}`, 404);
            }

            if (photo.eventId !== eventId) {
                throw new AppError('Photo does not belong to the specified event', 400);
            }

            // Get the appropriate S3 key based on the requested size
            let s3Key: string | undefined;
            
            if (photo.metadata?.s3Keys && photo.metadata.s3Keys[size]) {
                // Use the requested size if available
                s3Key = photo.metadata.s3Keys[size];
            } else if (photo.metadata?.s3Key) {
                // Fall back to the original key for legacy photos
                s3Key = photo.metadata.s3Key;
            } else if (photo.url) {
                // Try to extract from URL as last resort
                try {
                    const urlParts = new URL(photo.url);
                    s3Key = urlParts.pathname.substring(1); // Remove leading slash
                } catch (error) {
                    logger.error(`Error parsing photo URL: ${photo.url}`, error);
                    throw new AppError('Could not determine photo storage location', 500);
                }
            }

            if (!s3Key) {
                throw new AppError('Photo storage information missing', 500);
            }

            // Generate a filename for the download
            const sizeSuffix = size !== 'original' ? `_${size}` : '';
            const filename = `photo-${photoId}${sizeSuffix}.jpg`;

            // Get a download URL with content-disposition header
            return await this.s3Service.getDownloadUrl(s3Key, filename);
        } catch (error) {
            logger.error('Error generating photo download URL:', error);
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(
                `Failed to get photo download URL: ${(error as Error).message}`,
                500
            );
        }
    }

    /**
     * Get all photos for an organization across all events
     * @param orgName The organization name
     * @param userId The user ID requesting the photos
     * @returns Array of photos with their associated event information
     */
    async getAllOrganizationPhotos(
        orgName: string,
        userId: string
    ): Promise<{ photos: Photo[]; events: Map<string, EventModel> }> {
        try {
            // Check if the user is a member of the organization
            const orgService = new OrgService();
            const userOrg = await orgService.findSpecificOrgByUser(orgName, userId);

            if (!userOrg) {
                throw new AppError('You are not a member of this organization', 403);
            }

            // Get all events for the organization
            const eventService = new EventService();
            const events = await eventService.getAllOrganizationEvents(orgName);

            if (!events || events.length === 0) {
                return { photos: [], events: new Map() };
            }

            // Create a map of event IDs to event objects for easy reference
            const eventMap = new Map<string, EventModel>();
            events.forEach(event => {
                eventMap.set(event.id, event);
            });

            // Get photos for each event
            const photoPromises = events.map(event =>
                this.photoRepository.getPhotosByEvent(event.id)
            );
            const photoArrays = await Promise.all(photoPromises);

            // Flatten the array of photo arrays
            let allPhotos: Photo[] = [];
            photoArrays.forEach(photos => {
                allPhotos = allPhotos.concat(photos);
            });

            // Refresh pre-signed URLs for all photos
            for (const photo of allPhotos) {
                try {
                    // Check if the photo has the new urls structure
                    if (photo.metadata?.s3Keys) {
                        // Generate fresh pre-signed URLs for all sizes
                        photo.urls = await this.s3Service.getMultiplePreSignedUrls(photo.metadata.s3Keys);
                        // Update the main URL to be the original for backward compatibility
                        photo.url = photo.urls.original;
                    } else if (photo?.metadata?.s3Key) {
                        // Legacy photo - just update the main URL
                        photo.url = await this.s3Service.getLogoPreSignedUrl(photo.metadata.s3Key);
                    }
                } catch (error) {
                    logger.error(`Error refreshing pre-signed URL: ${error}`);
                    // Continue processing other photos even if one fails
                }
            }

            return { photos: allPhotos, events: eventMap };
        } catch (error) {
            logger.error('Error getting organization photos:', error);
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(
                `Failed to get organization photos: ${(error as Error).message}`,
                500
            );
        }
    }
}}

src/services/s3Service.ts:
{
import { AppError } from '../middleware/errorHandler';
import { v4 as uuidv4 } from 'uuid';
import { logger } from '../util/logger';
import { S3Repository } from '../repositories/s3Repository';
import { PhotoSizes } from '../models/Photo';

export class S3Service {
    private s3Repository: S3Repository;

    constructor(s3Repository: S3Repository = new S3Repository()) {
        this.s3Repository = s3Repository;
    }

    /**
     * Uploads a logo from a URL to S3
     * @param url The URL of the logo to upload
     * @param organizationName The name of the organization (used for creating the S3 key)
     * @returns The S3 key where the logo was uploaded
     */
    async uploadLogoFromUrl(url: string, organizationName: string): Promise<string> {
        try {
            // Validate URL
            const validUrl = new URL(url);

            // Fetch the image data from the URL
            const response = await fetch(url);
            if (!response.ok) {
                throw new AppError(`Failed to fetch image from URL: ${response.statusText}`, 400);
            }

            // Get the image data as an array buffer
            const imageData = await response.arrayBuffer();

            // Generate a unique key for the S3 object
            // Using prefix pattern: logos/<organizationName>/<uniqueId>.<extension>
            const urlParts = validUrl.pathname.split('.');
            const fileExtension = urlParts.length > 1 ? urlParts[urlParts.length - 1] : 'jpg';
            const sanitizedOrgName = organizationName.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();
            const s3Key = `logos/${sanitizedOrgName}/${uuidv4()}.${fileExtension}`;

            // Get content type or default to image/jpeg
            const contentType = response.headers.get('content-type') || 'image/jpeg';

            // Upload to S3 using the repository
            return await this.s3Repository.uploadFile(Buffer.from(imageData), s3Key, contentType);
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }

            logger.error('Error uploading logo to S3:', error);
            throw new AppError(`Failed to upload logo to S3: ${(error as Error).message}`, 500);
        }
    }

    /**
     * Uploads a file buffer directly to S3
     * @param fileBuffer The buffer containing file data
     * @param key The S3 key where the file will be stored
     * @param contentType The content type of the file
     * @returns The S3 key where the file was uploaded
     */
    async uploadFileBuffer(fileBuffer: Buffer, key: string, contentType: string): Promise<string> {
        try {
            return await this.s3Repository.uploadFile(fileBuffer, key, contentType);
        } catch (error) {
            logger.error('Error uploading file to S3:', error);
            throw new AppError(`Failed to upload file to S3: ${(error as Error).message}`, 500);
        }
    }

    /**
     * Uploads multiple resized images to S3
     * @param buffers Object containing buffers for different sizes
     * @param s3Keys Object containing S3 keys for different sizes
     * @param contentType The content type of the files
     * @returns Object containing the S3 keys for all uploaded files
     */
    async uploadResizedImages(
        buffers: Record<string, Buffer>,
        s3Keys: Record<string, string>,
        contentType: string
    ): Promise<Record<string, string>> {
        try {
            // Prepare array of file objects for upload
            const files = Object.entries(buffers).map(([size, buffer]) => ({
                buffer,
                key: s3Keys[size],
                contentType,
            }));

            // Upload all files to S3
            await this.s3Repository.uploadMultipleFiles(files);

            // Return the S3 keys
            return s3Keys;
        } catch (error) {
            logger.error('Error uploading resized images to S3:', error);
            throw new AppError(`Failed to upload resized images to S3: ${(error as Error).message}`, 500);
        }
    }

    /**
     * Gets a pre-signed URL for accessing a file in S3
     * @param s3Key The S3 key of the file
     * @param expiresIn The expiration time in seconds (default: 604800 = 7 days, the maximum)
     * @returns The pre-signed URL
     */
    async getLogoPreSignedUrl(s3Key: string, expiresIn: number = 604800): Promise<string> {
        return this.s3Repository.getPreSignedUrl(s3Key, expiresIn);
    }

    /**
     * Gets pre-signed URLs for multiple files in S3
     * @param s3Keys Object mapping size names to S3 keys
     * @param expiresIn The expiration time in seconds (default: 604800 = 7 days, the maximum)
     * @returns Object mapping size names to pre-signed URLs
     */
    async getMultiplePreSignedUrls(
        s3Keys: Record<string, string>,
        expiresIn: number = 604800
    ): Promise<PhotoSizes> {
        try {
            // Get all key values from the s3Keys object
            const keyArray = Object.values(s3Keys);

            // Get all pre-signed URLs
            const urlMap = await this.s3Repository.getMultiplePreSignedUrls(keyArray, expiresIn);

            // Rebuild the object with the size names and URLs
            const result: PhotoSizes = { original: '' };

            for (const [size, key] of Object.entries(s3Keys)) {
                if (urlMap[key]) {
                    result[size as keyof PhotoSizes] = urlMap[key];
                }
            }

            return result;
        } catch (error) {
            logger.error('Error getting multiple pre-signed URLs:', error);
            throw new AppError(`Failed to get multiple pre-signed URLs: ${(error as Error).message}`, 500);
        }
    }

    /**
     * Gets a pre-signed URL for downloading a file from S3
     * @param s3Key The S3 key of the file
     * @param filename The suggested filename for the download
     * @param expiresIn The expiration time in seconds (default: 604800 = 7 days, the maximum)
     * @returns The pre-signed URL with content-disposition header set
     */
    async getDownloadUrl(
        s3Key: string,
        filename: string,
        expiresIn: number = 604800
    ): Promise<string> {
        return this.s3Repository.getDownloadPreSignedUrl(s3Key, filename, expiresIn);
    }

    /**
     * Deletes a file from S3
     * @param s3Key The S3 key of the file to delete
     */
    async deleteFile(s3Key: string): Promise<void> {
        return this.s3Repository.deleteFile(s3Key);
    }

    /**
     * Deletes multiple files from S3
     * @param s3Keys Array of S3 keys to delete
     */
    async deleteMultipleFiles(s3Keys: string[]): Promise<void> {
        return this.s3Repository.deleteMultipleFiles(s3Keys);
    }
    /**
 * Uploads a logo file directly to S3
 * @param fileBuffer The buffer containing logo file data
 * @param organizationName The name of the organization (used for creating the S3 key)
 * @param mimeType The mimetype of the file
 * @returns The S3 key where the logo was uploaded
 */
    async uploadLogoFromBuffer(
        fileBuffer: Buffer,
        organizationName: string,
        mimeType: string
    ): Promise<string> {
        try {
            // Extract file extension from mimetype
            const fileExtension = mimeType.split('/')[1] || 'jpg';

            // Sanitize organization name for use in S3 key
            const sanitizedOrgName = organizationName.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();

            // Generate a unique key for the S3 object
            const s3Key = `logos/${sanitizedOrgName}/${uuidv4()}.${fileExtension}`;

            // Upload to S3 using the repository
            return await this.s3Repository.uploadFile(fileBuffer, s3Key, mimeType);
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }

            logger.error('Error uploading logo to S3:', error);
            throw new AppError(`Failed to upload logo to S3: ${(error as Error).message}`, 500);
        }
    }
}}

src/services/tagService.ts:
{
import { TagRepository } from '../repositories/tagRepository';
import { PhotoRepository } from '../repositories/photoRepository';
import { S3Service } from './s3Service';
import { EventRepository } from '../repositories/eventRepository';
import { Tag, createTag, TagRequest } from '../models/Tag';
import { AppError } from '../middleware/errorHandler';
import { Photo } from '../models/Photo';
import { logger } from '../util/logger';
import { UserService } from './userService';
import { EventUser } from '../models/Event'; // Import EventUser
import { User } from '../models/User'; // Import User

// Define a new type for attendee with details
export interface AttendeeWithDetails {
    attendeeInfo: EventUser; // Keep the original EventUser info
    userDetails: Omit<User, 'password'> | null; // Add user details (without password)
}

export class TagService {
    private tagRepository: TagRepository;
    private photoRepository: PhotoRepository;
    private s3Service: S3Service;
    private eventRepository: EventRepository;
    private userService: UserService;

    constructor(
        tagRepository: TagRepository = new TagRepository(),
        photoRepository: PhotoRepository = new PhotoRepository(),
        s3Service: S3Service = new S3Service(),
        eventRepository: EventRepository = new EventRepository(),
        userService: UserService = new UserService() // Ensure userService is initialized
    ) {
        this.tagRepository = tagRepository;
        this.photoRepository = photoRepository;
        this.s3Service = s3Service;
        this.eventRepository = eventRepository;
        this.userService = userService;
    }

    /**
     * Tags multiple users in a photo
     * Only users who are attending the event can be tagged
     * @param tagRequest The tag request containing userIds, photoId and eventId
     * @param taggedBy The ID of the user creating the tags (must be an admin)
     * @returns Array of created tags
     */
    async tagUsersInPhoto(tagRequest: TagRequest, taggedBy: string): Promise<Tag[]> {
        try {
            const { userIds, photoId, eventId } = tagRequest;

            // Verify the photo exists and belongs to the event
            const photo = await this.photoRepository.getPhotoById(photoId);
            if (!photo) {
                throw new AppError(`Photo not found: ${photoId}`, 404);
            }

            if (photo.eventId !== eventId) {
                throw new AppError('Photo does not belong to the specified event', 400);
            }

            // Get all users attending the event (just their IDs in USER#userId format)
            const attendingUserIds = await this.getEventAttendees(eventId); // Use the ID-only version here

            // Create tags for each user who is attending the event
            const tags: Tag[] = [];
            const invalidUsers: string[] = [];

            for (const userId of userIds) {
                // Check if the user exists
                const user = await this.userService.getUserById(userId);
                if (!user) {
                    invalidUsers.push(`User not found: ${userId}`);
                    continue;
                }

                // Check if the user is attending the event by comparing against the fetched IDs
                const isAttending = attendingUserIds.some(attendeeId => attendeeId === `USER#${userId}`);
                if (!isAttending) {
                    invalidUsers.push(`User ${userId} is not attending this event`);
                    continue;
                }

                // Check if the user is already tagged in this photo
                const existingTag = await this.tagRepository.getTagByUserAndPhoto(userId, photoId);
                if (existingTag) {
                    continue; // Skip this user as they're already tagged
                }

                // Create the tag
                const tag = createTag(userId, photoId, eventId, taggedBy);
                tags.push(tag);
            }

            // Create all tags in a batch operation if there are any to create
            if (tags.length > 0) {
                await this.tagRepository.batchCreateTags(tags);
            }

            // If there were invalid users, log them but don't fail the operation
            if (invalidUsers.length > 0) {
                logger.warn(`Some users could not be tagged: ${invalidUsers.join(', ')}`);
            }

            return tags;
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(`Failed to tag users in photo: ${(error as Error).message}`, 500);
        }
    }

    /**
     * Gets all users attending an event along with their details.
     * @param eventId The event ID
     * @returns Array of AttendeeWithDetails objects
     * @throws AppError if fetching fails
     */
    async getEventAttendeesWithDetails(eventId: string): Promise<AttendeeWithDetails[]> {
        try {
            // Fetch the basic EventUser records for attendees
            const eventUsers: EventUser[] = await this.eventRepository.getEventAttendees(eventId);

            if (!eventUsers || eventUsers.length === 0) {
                return [];
            }

            // Fetch user details for each attendee
            const attendeesWithDetails = await Promise.all(
                eventUsers.map(async (eventUser) => {
                    // Extract userId from the PK (format: USER#userId)
                    const userId = eventUser.PK.split('#')[1];
                    let userDetails: Omit<User, 'password'> | null = null;

                    if (userId) {
                        try {
                            const user = await this.userService.getUserById(userId);
                            if (user) {
                                // Exclude password before assigning
                                const { password, ...details } = user;
                                userDetails = details;
                            }
                        } catch (userError) {
                            logger.error(`Failed to fetch details for user ${userId}:`, userError);
                            // Keep userDetails as null if fetch fails
                        }
                    }

                    return {
                        attendeeInfo: eventUser, // Keep the original EventUser record
                        userDetails: userDetails,
                    };
                })
            );

            return attendeesWithDetails;
        } catch (error) {
            logger.error('Error getting event attendees with details:', error);
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(`Failed to get event attendees: ${(error as Error).message}`, 500);
        }
    }

    /**
     * Gets all users who are attending an event (Only IDs - kept for potential internal use)
     * @param eventId The event ID
     * @returns Array of user IDs (format USER#userId)
     */
    async getEventAttendees(eventId: string): Promise<string[]> {
        try {
            const eventUsers = await this.eventRepository.getEventAttendees(eventId);
            // Return the PK which is in USER#userId format
            return eventUsers.map(eu => eu.PK);
        } catch (error) {
            logger.error('Error getting event attendees:', error);
            throw new AppError(`Failed to get event attendees: ${(error as Error).message}`, 500);
        }
    }

    /**
     * Gets all photos a user is tagged in
     * @param userId The user's ID
     * @returns Array of photos with tag information
     */
    async getUserTaggedPhotos(userId: string): Promise<Photo[]> {
        try {
            // Get all tags for the user
            const tags = await this.tagRepository.getTagsByUser(userId);

            if (tags.length === 0) {
                return [];
            }

            // Get the photo details for each tag
            const photoPromises = tags.map(tag => this.photoRepository.getPhotoById(tag.photoId));
            const photos = await Promise.all(photoPromises);

            // Filter out any null results and refresh pre-signed URLs
            const validPhotos = photos.filter(photo => photo !== null) as Photo[];

            // Refresh pre-signed URLs for all photos
            for (const photo of validPhotos) {
                try {
                    // Check if the photo has the new urls structure
                    if (photo.metadata?.s3Keys) {
                        // Generate fresh pre-signed URLs for all sizes
                        photo.urls = await this.s3Service.getMultiplePreSignedUrls(photo.metadata.s3Keys);
                        // Update the main URL to be the original for backward compatibility
                        photo.url = photo.urls.original;
                    } else if (photo?.metadata?.s3Key) {
                        // Legacy photo - just update the main URL
                        photo.url = await this.s3Service.getLogoPreSignedUrl(photo.metadata.s3Key);
                    } else if (photo?.url) {
                        // Very old format - try to extract the key from the URL
                        try {
                            const urlParts = new URL(photo.url);
                            const s3Key = urlParts.pathname.substring(1); // Remove leading slash
                            photo.url = await this.s3Service.getLogoPreSignedUrl(s3Key);
                        } catch (error) {
                            logger.error(`Error refreshing pre-signed URL for photo: ${error}`);
                            // Keep original URL if parsing fails
                        }
                    }
                } catch (error) {
                    logger.error(`Error refreshing pre-signed URL: ${error}`);
                    // Continue processing other photos even if one fails
                }
            }

            return validPhotos;
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(
                `Failed to get user tagged photos: ${(error as Error).message}`,
                500
            );
        }
    }

    /**
     * Gets all users tagged in a photo
     * @param photoId The photo's ID
     * @returns Array of tags with user information
     */
    async getPhotoTags(photoId: string): Promise<any[]> {
        try {
            // Get all tags for the photo
            const tags = await this.tagRepository.getTagsByPhoto(photoId);

            if (tags.length === 0) {
                return [];
            }

            // Get user details for each tag
            const taggedUsers = await Promise.all(
                tags.map(async tag => {
                    const user = await this.userService.getUserById(tag.userId);
                    return {
                        tag,
                        user: user
                            ? {
                                id: user.id,
                                email: user.email,
                                firstName: user.firstName,
                                lastName: user.lastName,
                            }
                            : null,
                    };
                })
            );

            return taggedUsers.filter(item => item.user !== null);
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(`Failed to get photo tags: ${(error as Error).message}`, 500);
        }
    }

    /**
     * Removes a tag (untags a user from a photo)
     * @param userId The user's ID
     * @param photoId The photo's ID
     * @returns True if successful
     */
    async removeTag(userId: string, photoId: string): Promise<boolean> {
        try {
            // Verify the tag exists
            const tag = await this.tagRepository.getTagByUserAndPhoto(userId, photoId);

            if (!tag) {
                throw new AppError(`User is not tagged in this photo`, 404);
            }

            // Delete the tag
            return await this.tagRepository.deleteTag(userId);
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(`Failed to remove tag: ${(error as Error).message}`, 500);
        }
    }
}
}

src/services/userService.ts:
{
import { UserRepository } from '../repositories/userRepository';
import { User, RegisterRequest, createUserFromRegister, AuthRequest, PasswordChangeRequest } from '../models/User';
import { AppError } from '../middleware/errorHandler';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';

export class UserService {
    private userRepository: UserRepository;

    constructor(userRepository: UserRepository = new UserRepository()) {
        this.userRepository = userRepository;
    }

    async getUserByEmail(email: string): Promise<User | null> {
        return await this.userRepository.findUserByEmail(email);
    }

    async register(
        registerRequest: RegisterRequest
    ): Promise<{ user: Omit<User, 'password'>; token: string }> {
        try {
            // Check if user with this email already exists
            const existingUser = await this.getUserByEmail(registerRequest.email);

            if (existingUser) {
                throw new AppError('Email already in use', 409);
            }

            // Create a new user object
            const user = createUserFromRegister(registerRequest);

            // Hash the password before storing
            const salt = await bcrypt.genSalt(10);
            user.password = await bcrypt.hash(user.password, salt);

            try {
                // Save the user to the database
                const createdUser = await this.userRepository.createUser(user);

                // Generate JWT token
                const token = this.generateToken(createdUser);

                // Return user (without password) and token
                const { password, ...userWithoutPassword } = createdUser;

                return {
                    user: userWithoutPassword as Omit<User, 'password'>,
                    token,
                };
            } catch (error) {
                // This will specifically catch the database error from createUser
                throw new AppError(`Registration failed: ${(error as Error).message}`, 500);
            }
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(`Registration failed: ${(error as Error).message}`, 500);
        }
    }

    async login(
        authRequest: AuthRequest
    ): Promise<{ user: Omit<User, 'password'>; token: string }> {
        try {
            // Find user by email
            const user = await this.getUserByEmail(authRequest.email);

            // If user doesn't exist
            if (!user) {
                throw new AppError('Invalid email or password', 401);
            }

            // Check if the password is correct
            const isPasswordValid = await bcrypt.compare(authRequest.password, user.password);

            if (!isPasswordValid) {
                throw new AppError('Invalid email or password', 401);
            }

            // Generate JWT token
            const token = this.generateToken(user);

            // Return user (without password) and token
            const { password, ...userWithoutPassword } = user;

            return {
                user: userWithoutPassword as Omit<User, 'password'>,
                token,
            };
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(`Login failed: ${(error as Error).message}`, 500);
        }
    }

    /**
     * Change user password
     * @param passwordChangeRequest Request with user ID, current password and new password
     * @returns Boolean indicating success
     */
    async changePassword(passwordChangeRequest: PasswordChangeRequest): Promise<boolean> {
        const { userId, currentPassword, newPassword } = passwordChangeRequest;

        try {
            // Get the user to make sure they exist
            const user = await this.userRepository.getUserById(userId);
            if (!user) {
                throw new AppError('User not found', 404);
            }

            // Verify current password
            const isCurrentPasswordValid = await bcrypt.compare(currentPassword, user.password);
            if (!isCurrentPasswordValid) {
                throw new AppError('Current password is incorrect', 401);
            }

            // Hash the new password
            const salt = await bcrypt.genSalt(10);
            const hashedNewPassword = await bcrypt.hash(newPassword, salt);

            // Update the password in the database
            const updated = await this.userRepository.updateUserPassword(userId, hashedNewPassword);

            return updated;
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(`Failed to change password: ${(error as Error).message}`, 500);
        }
    }

    private generateToken(user: User): string {
        return jwt.sign(
            {
                id: user.id,
                email: user.email,
                role: user.role,
            },
            process.env.JWT_SECRET as string,
            { expiresIn: '24h' }
        );
    }

    /**
     * Get a user by ID
     * @param userId The ID of the user to retrieve
     * @returns The user or null if not found
     */
    async getUserById(userId: string): Promise<User | null> {
        try {
            return await this.userRepository.getUserById(userId);
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(`Failed to get user by ID: ${(error as Error).message}`, 500);
        }
    }

    /**
     * Deletes a user and all their membership records and event attendance records
     * @param userId The ID of the user to delete
     * @returns Boolean indicating success
     */
    async deleteUser(userId: string): Promise<boolean> {
        try {
            // First get the user to make sure they exist
            const user = await this.userRepository.getUserById(userId);
            if (!user) {
                throw new AppError('User not found', 404);
            }

            // Delete all event attendance records
            const deletedEventAttendance =
                await this.userRepository.deleteUserEventAttendance(userId);

            // Delete all organization memberships
            const deletedMemberships =
                await this.userRepository.deleteUserOrganizationMemberships(userId);

            // Delete the user entity
            const deletedUser = await this.userRepository.deleteUser(userId);

            return deletedUser && deletedMemberships && deletedEventAttendance;
        } catch (error) {
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(`Failed to delete user: ${(error as Error).message}`, 500);
        }
    }
}}

src/services/weatherService.ts:
{
import { AppError } from '../middleware/errorHandler';
import { logger } from '../util/logger';

export interface WeatherData {
    temperature: number;
    weatherCode: number;
    windSpeed: number;
    precipitation: number;
    weatherDescription: string;
}

interface WeatherApiResponse {
    daily: {
        time: string[];
        temperature_2m_max: number[];
        weathercode: number[];
        precipitation_sum: number[];
        windspeed_10m_max: number[];
    };
}

export class WeatherService {
    private baseUrl = 'https://api.open-meteo.com/v1/forecast';

    /**
     * Get weather data for a specific location and date
     * @param latitude Latitude of the location
     * @param longitude Longitude of the location
     * @param date Date in ISO format (YYYY-MM-DD)
     * @returns Weather data for the specified location and date
     */
    async getWeatherForLocation(
        latitude: number,
        longitude: number,
        date: string
    ): Promise<WeatherData> {
        try {
            // Format date to YYYY-MM-DD if it's a full ISO string
            const formattedDate = date.split('T')[0];

            const url = new URL(this.baseUrl);
            url.searchParams.append('latitude', latitude.toString());
            url.searchParams.append('longitude', longitude.toString());
            url.searchParams.append(
                'daily',
                'temperature_2m_max,weathercode,precipitation_sum,windspeed_10m_max'
            );
            url.searchParams.append('timezone', 'auto');
            url.searchParams.append('start_date', formattedDate);
            url.searchParams.append('end_date', formattedDate);

            const response = await fetch(url.toString());

            if (!response.ok) {
                throw new AppError(`Failed to fetch weather data: ${response.statusText}`, 500);
            }

            // Type the response data to match the expected structure
            const data = (await response.json()) as WeatherApiResponse;

            if (!data.daily || !data.daily.time || data.daily.time.length === 0) {
                throw new AppError('Invalid weather data format received', 500);
            }

            const weatherCode = data.daily.weathercode[0];

            return {
                temperature: data.daily.temperature_2m_max[0],
                weatherCode: weatherCode,
                windSpeed: data.daily.windspeed_10m_max[0],
                precipitation: data.daily.precipitation_sum[0],
                weatherDescription: this.getWeatherDescription(weatherCode),
            };
        } catch (error) {
            logger.error('Error fetching weather data:', error);
            if (error instanceof AppError) {
                throw error;
            }
            throw new AppError(`Failed to get weather data: ${(error as Error).message}`, 500);
        }
    }

    /**
     * Maps a WMO weather code to a human-readable description
     * @param code WMO weather code
     * @returns Human-readable weather description
     */
    private getWeatherDescription(code: number): string {
        // WMO Weather interpretation codes (WW)
        const weatherCodes: Record<number, string> = {
            0: 'Clear sky',
            1: 'Mainly clear',
            2: 'Partly cloudy',
            3: 'Overcast',
            45: 'Fog',
            48: 'Depositing rime fog',
            51: 'Light drizzle',
            53: 'Moderate drizzle',
            55: 'Dense drizzle',
            56: 'Light freezing drizzle',
            57: 'Dense freezing drizzle',
            61: 'Slight rain',
            63: 'Moderate rain',
            65: 'Heavy rain',
            66: 'Light freezing rain',
            67: 'Heavy freezing rain',
            71: 'Slight snow fall',
            73: 'Moderate snow fall',
            75: 'Heavy snow fall',
            77: 'Snow grains',
            80: 'Slight rain showers',
            81: 'Moderate rain showers',
            82: 'Violent rain showers',
            85: 'Slight snow showers',
            86: 'Heavy snow showers',
            95: 'Thunderstorm',
            96: 'Thunderstorm with slight hail',
            99: 'Thunderstorm with heavy hail',
        };

        return weatherCodes[code] || 'Unknown';
    }
}
}

src/util/logger.ts:
{
import { createLogger, transports, format } from 'winston';

const logger = createLogger({
    format: format.combine(
        format.timestamp(),
        format.printf(({ timestamp, level, message }) => {
            return `${timestamp} [${level}]: ${message}`;
        })
    ),
    transports: [
        new transports.Console(),
        new transports.File({ filename: './src/util/project.log' }),
    ],
});

export { logger };
}

src/util/mailService.ts:
{
import nodemailer from 'nodemailer';
import { logger } from './logger';
import dotenv from 'dotenv';

dotenv.config();

const sendMail = async (to: string, subject: string, message: string, header: string) => {
    const transporter = nodemailer.createTransport({
        service: process.env.MAIL_HOST,
        auth: {
            user: process.env.MAIL_USERNAME,
            pass: process.env.MAIL_PASSWORD,
        },
    });

    const mailOptions = {
        from: `PhotoComp Admin: ${process.env.MAIL_USERNAME}`,
        template: 'email',
        to: to,
        subject: subject,
        text: `${header}
        ${message}`,
    };

    logger.info(`Sending mail to - ${to}`);
    transporter.sendMail(mailOptions, (error, info) => {
        if (error) {
            logger.error(error);
        } else {
            logger.info('Email sent: ' + info.response);
        }
    });
};

export { sendMail };
}

scripts/clean_directory.sh:
{
#!/bin/bash
# Clean the deployment directory except for hidden files like .env potentially
echo "Cleaning deployment directory /var/www/photocomp-api..."
shopt -s extglob # Enable extended globbing
rm -rf /var/www/photocomp-api/!(.|..?|.env) # Remove everything except hidden files/dirs and .env
echo "Deployment directory cleaned."
exit 0}

scripts/fetch_env_vars.sh:
{
#!/bin/bash
# Fetch parameters from AWS Systems Manager Parameter Store and create .env file
echo "Fetching environment variables from Parameter Store..."
cd /var/www/photocomp-api

PARAM_PATH="/photocomp/dev/"
REGION="us-west-2"
ENV_FILE=".env"

# Fetch parameters and format them into KEY=Value pairs
# Using --query to extract Name and Value, text output, and processing with awk
aws ssm get-parameters-by-path --path "$PARAM_PATH" --recursive --with-decryption --region "$REGION" \
  --query "Parameters[].[Name,Value]" --output text | \
  awk -v path="$PARAM_PATH" '{
    key = $1
    sub(path, "", key) # Remove the path prefix from the key name
    # Everything after the first field ($1) is the value
    value = ""
    for (i=2; i<=NF; i++) { value = (value ? value FS : "") $i }
    print key "=" value
  }' > "$ENV_FILE"

if [ $? -eq 0 ]; then
  echo "Successfully fetched parameters and created $ENV_FILE"
  # Optional: Set permissions for the .env file
  # chmod 600 $ENV_FILE
  # chown ec2-user:ec2-user $ENV_FILE # Use 'ubuntu:ubuntu' for Ubuntu
else
  echo "ERROR: Failed to fetch parameters from Parameter Store." >&2
  exit 1
fi

exit 0}

scripts/install_dependencies.sh:
{
#!/bin/bash
# Install production dependencies
echo "Installing production dependencies..."
cd /var/www/photocomp-api
npm ci --production --omit=dev # Install only production deps, faster than install
echo "Dependencies installed."
# Optional: Set permissions if needed
# chown -R ec2-user:ec2-user /var/www/photocomp-api # Use 'ubuntu:ubuntu' for Ubuntu
exit 0}

scripts/start_server.sh:
{
#!/bin/bash
# Start the application using PM2
echo "Starting PhotoComp API server with PM2..."
cd /var/www/photocomp-api
export PM2_HOME=/home/ec2-user/.pm2 # Specify PM2 home (use /home/ubuntu/.pm2 for Ubuntu)
# Start the application using the built JS file in dist/
# Ensure NODE_ENV is set correctly for dotenv to potentially load .env if needed,
# although parameters are fetched directly here. PM2 can manage NODE_ENV.
pm2 start dist/index.js --name photocomp-api --env production --update-env
# Optional: Configure PM2 to restart on crashes/reboots
# pm2 startup # Run this manually once or in user data to generate command
# pm2 save    # Save the current process list
echo "PhotoComp API server started."
exit 0}

scripts/stop_server.sh:
{
#!/bin/bash
# Stop and delete the existing application process managed by PM2
echo "Stopping PhotoComp API server..."
export PM2_HOME=/home/ec2-user/.pm2 # Specify PM2 home for the runas user (use /home/ubuntu/.pm2 for Ubuntu)
pm2 stop photocomp-api || true
pm2 delete photocomp-api || true
echo "PhotoComp API server stopped."
exit 0 # Ensure the script exits successfully}

scripts/validate_service.sh:
{
#!/bin/bash
# Validate that the service is running and responding
echo "Validating PhotoComp API service..."

# Wait a few seconds for the Node.js process to fully start
sleep 5

echo "Attempting validation check via curl..."
# Use curl to check the root endpoint on the configured port
# -f: Fail silently (no output) on HTTP errors (status >= 400)
# --connect-timeout: Max time allowed for connection
# -s: Silent mode (suppress progress meter)
# -o /dev/null: Discard response body
if curl -f -s --connect-timeout 5 http://localhost:3000/ -o /dev/null; then
    echo "Service validation successful. Endpoint / responded with 2xx."
    exit 0
else
    echo "ERROR: Service validation failed. curl command exited with status $?." >&2
    # Provide more debugging info if curl fails
    echo "Checking PM2 status..."
    export PM2_HOME=/home/ec2-user/.pm2 # Ensure PM2 env is set for this user
    pm2 list
    echo "Fetching recent PM2 logs for photocomp-api..."
    pm2 logs photocomp-api --lines 20 --nostream # Show last 20 lines without streaming
    exit 1
fi}

